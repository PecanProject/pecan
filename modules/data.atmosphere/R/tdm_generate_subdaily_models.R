##' Generate Subdaily Models
##' Create statistical models to predict subdaily meteorology
# -----------------------------------
# Description
# -----------------------------------
##'
##' @title gen.subdaily.models
##' @family tdm - Temporally Downscale Meteorology
##' @author Christy Rollinson, James Simkins
##' @description This is the 2nd function in the tdm workflow that takes the dat.train_file that is created from the
##'              nc2dat.train function and generates "lag.days" and "next.days". These variables pass along information
##'              of the previous time step and provides a preview of the next time step. After these variables are created,
##'              the models are generated by calling the tdm_temporal_downscale_functions.R scripts and these models
##'              and betas are saved separately. Please note that these models and betas require a significant
##'              amount of space. The storage required varies by the size of the training dataset, but prepare for
##'              >100 GB. These will be called later in tdm_predict_subdaily_met to perform the linear regression
##'              analysis.
# -----------------------------------
# Parameters
# -----------------------------------
##' @param outfolder - directory where models will be stored *** storage required varies by size of training dataset, but prepare for >100 GB
##' @param dat.train_file - train_data file
##' @param in.prefix 
##' @param n.beta - number of betas to save from linear regression model
##' @param resids - logical stating whether to pass on residual data or not
##' @param parallel - logical stating whether to run temporal_downscale_functions.R in parallel 
##' @param n.cores - deals with parallelization
##' @param day.window - integer specifying number of days around the day being modeled you want to use data from for that 
##'                     specific hours coefficients. Must be integer because we want statistics from the same time of day
##'                     for each day surrounding the model day
##' @param overwrite
##' @param verbose
##' @export
# -----------------------------------
#----------------------------------------------------------------------
# Begin Function
#----------------------------------------------------------------------


gen.subdaily.models <- function(outfolder, dat.train_file, in.prefix, 
    n.beta, day.window, resids = FALSE, parallel = FALSE, n.cores = NULL, overwrite = TRUE, 
    verbose = FALSE) {
  
    pb.index <- 1
    pb <- txtProgressBar(min = 1, max = 8, style = 3)
    
    # ----- 1.0 Read data & Make time stamps ---------- Load the data
    
    vars.info <- data.frame(CF.name = c("air_temperature", "precipitation_flux", "air_temperature_max", 
                                        "air_temperature_min", "surface_downwelling_shortwave_flux_in_air", 
                                        "surface_downwelling_longwave_flux_in_air", "air_pressure", "specific_humidity", 
                                        "eastward_wind", "northward_wind", "wind_speed"))
    dat.train <- list()
    tem <- ncdf4::nc_open(dat.train_file)
    dim <- tem$dim
    for (j in seq_along(vars.info$CF.name)) {
      if (exists(as.character(vars.info$CF.name[j]), tem$var)) {
        dat.train[[j]] <- ncdf4::ncvar_get(tem, as.character(vars.info$CF.name[j]))
      } else {
        dat.train[[j]] = NA
      }
    }
    names(dat.train) <- vars.info$CF.name
    dat.train <- data.frame(dat.train)
    
    # create wind speed variable if we're only given component wind speeds
    if (all(is.na(dat.train$wind_speed) == TRUE)){
      dat.train$wind_speed <- sqrt(dat.train$eastward_wind^2 + dat.train$northward_wind^2)
    }
    
    # adding a temporary date variable for the model
    if (dim$time$units == "sec"){
      sub_string<- substrRight(dat.train_file, 7)
      start_year <- substr(sub_string, 1, 4)
      dat.train$date <- as.Date((dim$time$vals/(dim$time$vals[2] - dim$time$vals[1])), 
                                tz="GMT", origin = paste0(start_year - 1, "-12-31"))
    } else {
      start_year <- substr(dim$time$units,start = 12,stop = 15)
      dat.train$date = as.POSIXct(udunits2::ud.convert((dim$time$vals - ((dim$time$vals[2] - dim$time$vals[1])/2)),"days", "seconds"),
                                  tz="GMT", origin = paste0(start_year, "-01-01 00:00:00"))
    }
    # Getting additional time stamps
    dat.train$year <- lubridate::year(dat.train$date)
    dat.train$doy <- lubridate::yday(dat.train$date)
    dat.train$hour <- lubridate::hour(dat.train$date)
    
    
    # these non-standard variables help us organize our modeling approach
    dat.train$date <- strptime(paste(dat.train$year, dat.train$doy + 1, 
        dat.train$hour, sep = "-"), "%Y-%j-%H", tz = "GMT")
    dat.train$time.hr <- as.numeric(difftime(dat.train$date, paste0((min(dat.train$year) - 
        1), "-12-31 ", max(unique(dat.train$hour)),":00:00"), tz = "GMT", units = "hour"))
    dat.train$time.day <- as.numeric(difftime(dat.train$date, paste0((min(dat.train$year) - 
        1), "-12-31 ", max(unique(dat.train$hour)),":00:00"), tz = "GMT", units = "day")) - 1/24
    dat.train$time.day2 <- as.integer(dat.train$time.day + 1/(48 * 2)) + 
        1  # Offset by half a time step to get time stamps to line up
    
    # ----- 1.1 Coming up with the daily means that are what we can
    # use as predictors ----------
    
    train.day <- aggregate(dat.train[, c("air_temperature", "precipitation_flux", 
        "surface_downwelling_shortwave_flux_in_air", "surface_downwelling_longwave_flux_in_air", 
        "air_pressure", "specific_humidity", "wind_speed")], by = dat.train[, 
        c("year", "doy")], FUN = mean)
    names(train.day)[3:9] <- c("air_temperature_mean.day", "precipitation_flux.day", 
        "surface_downwelling_shortwave_flux_in_air.day", "surface_downwelling_longwave_flux_in_air.day", 
        "air_pressure.day", "specific_humidity.day", "wind_speed.day")
    train.day$air_temperature_max.day <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy")], FUN = max)$x
    train.day$air_temperature_min.day <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy")], FUN = min)$x

    dat.train <- merge(dat.train[, ], train.day, all.x = T, all.y = T)

    # ----- 1.2 Setting up a 1-hour lag -- smooth transitions at
    # midnight NOTE: because we're filtering from the present back through
    # the past, -1 will associate the closest hour that we've already done
    # (midnight) with the day we're currently working on ----------
    vars.hour <- c("air_temperature", "precipitation_flux", "surface_downwelling_shortwave_flux_in_air", 
        "surface_downwelling_longwave_flux_in_air", "air_pressure", "specific_humidity", 
        "wind_speed")
    vars.lag <- c("lag.air_temperature", "lag.precipitation_flux", "lag.surface_downwelling_shortwave_flux_in_air", 
        "lag.surface_downwelling_longwave_flux_in_air", "lag.air_pressure", 
        "lag.specific_humidity", "lag.wind_speed")
    lag.day <- dat.train[dat.train$hour == max(unique(dat.train$hour)), c("year", "doy", "time.day2", 
        vars.hour)]
    names(lag.day)[4:10] <- vars.lag
    
    lag.day <- aggregate(lag.day[, vars.lag], by = lag.day[, c("year", 
        "doy", "time.day2")], FUN = mean)
    lag.day$lag.air_temperature_min <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy", "time.day2")], FUN = min)[, "x"]  # Add in a lag for the next day's min temp
    lag.day$lag.air_temperature_max <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy", "time.day2")], FUN = max)[, "x"]  # Add in a lag for the next day's min temp
    lag.day$time.day2 <- lag.day$time.day2 + 1  # +1 for forward filtering downscale
    
    
    dat.train <- merge(dat.train, lag.day[, c("time.day2", vars.lag, "lag.air_temperature_min", 
        "lag.air_temperature_max")], all.x = T)
    
    # ----- 1.3 Setting up a variable to 'preview' the next day's mean
    # to help get smoother transitions NOTE: because we're filtering from
    # the present back through the past, +1 will associate the mean for the
    # next day we're going to model with the one we're currently working on
    # ----------
    vars.day <- c("air_temperature_mean.day", "air_temperature_max.day", 
        "air_temperature_mean.day", "precipitation_flux.day", "surface_downwelling_shortwave_flux_in_air.day", 
        "surface_downwelling_longwave_flux_in_air.day", "air_pressure.day", 
        "specific_humidity.day", "wind_speed.day")
    vars.next <- c("next.air_temperature_mean", "next.air_temperature_max", 
        "next.air_temperature_min", "next.precipitation_flux", "next.surface_downwelling_shortwave_flux_in_air", 
        "next.surface_downwelling_longwave_flux_in_air", "next.air_pressure", 
        "next.specific_humidity", "next.wind_speed")
    
    next.day <- dat.train[c("year", "doy", "time.day2", vars.day)]
    names(next.day)[4:12] <- vars.next
    next.day <- aggregate(next.day[, vars.next], by = next.day[, c("year", 
        "doy", "time.day2")], FUN = mean)
    next.day$time.day2 <- next.day$time.day2 - 1
    
    dat.train <- merge(dat.train, next.day[, c("time.day2", vars.next)], 
        all.x = T)
    
    # ----- 1.4 calculate air_temperature_min & air_temperature_max as
    # departure from mean; order data ---------- Lookign at max & min as
    # departure from mean
    dat.train$max.dep <- dat.train$air_temperature_max.day - dat.train$air_temperature_mean.day
    dat.train$min.dep <- dat.train$air_temperature_min.day - dat.train$air_temperature_mean.day
    # ----- 2.1 Generating all the daily models, save the output as
    # .Rdata files, then clear memory Note: Could save Betas as .nc files
    # that we pull from as needed to save memory; but for now just leaving
    # it in the .Rdata file for eas Note: To avoid propogating too much
    # wonkiness in hourly data, any co-variates are at the daily level
    # Note: If mod.precipitation_flux.doy doesn't run, try increasing the
    # day.window for this variable. The lack of non-zero values makes it
    # difficult for the linear regression model to calculate coefficients
    # sometimes ---------

    temporal.downscale.functions(dat.train = dat.train, n.beta = n.beta, day.window = day.window, 
                                 resids = resids, n.cores = n.cores, 
                                 seed = format(Sys.time(), "%m%d"), outfolder = outfolder, 
                                 in.prefix = in.prefix) 
}

# Helper function
substrRight <- function(x, n) {
  substr(x, nchar(x) - n + 1, nchar(x))
}
