##' Generate Subdaily Models
##' Create statistical models to predict subdaily meteorology
# -----------------------------------
# Description
# -----------------------------------
##'
##' @title gen.subdaily.models
##' @family tdm - Temporally Downscale Meteorology
##' @author Christy Rollinson, James Simkins
##' @description This is the 2nd function in the tdm workflow that takes the dat.train_file that is created from the
##'              nc2dat.train function and generates "lag.days" and "next.days". These variables pass along information
##'              of the previous time step and provides a preview of the next time step. After these variables are created,
##'              the models are generated by calling the tdm_temporal_downscale_functions.R scripts and these models
##'              and betas are saved separately. Please note that these models and betas require a significant
##'              amount of space. The storage required varies by the size of the training dataset, but prepare for
##'              >100 GB. These will be called later in tdm_predict_subdaily_met to perform the linear regression
##'              analysis.
# -----------------------------------
# Parameters
# -----------------------------------
##' @param outfolder - directory where models will be stored *** storage required varies by size of training dataset, but prepare for >10 GB
##' @param path.train - path to CF/PEcAn style training data where each year is in a separate file.
##' @param yrs.train - which years of the training data should be used for to generate the model for 
##'                    the subdaily cycle.  If NULL, will default to all years
##' @param direction.filter - Whether the model will be filtered backwards or forwards in time. options = c("backward", "forward")
##'                           (PalEON will go backwards, anybody interested in the future will go forwards)                  
##' @param in.prefix 
##' @param n.beta - number of betas to save from linear regression model
##' @param resids - logical stating whether to pass on residual data or not (this increases both memory & storage requirements)
##' @param parallel - logical stating whether to run temporal_downscale_functions.R in parallel 
##' @param n.cores - deals with parallelization
##' @param day.window - integer specifying number of days around the day being modeled you want to use data from for that 
##'                     specific hours coefficients. Must be integer because we want statistics from the same time of day
##'                     for each day surrounding the model day
##' @param seed - seed for randomization to allow for reproducible results                    
##' @param overwrite
##' @param verbose
##' @export
# -----------------------------------
#----------------------------------------------------------------------
# Begin Function
#----------------------------------------------------------------------


gen.subdaily.models <- function(outfolder, path.train, yrs.train, direction.filter, in.prefix,  
    n.beta, day.window, resids = FALSE, parallel = FALSE, n.cores = NULL, overwrite = TRUE, 
    verbose = FALSE) {
  
    # pb.index <- 1
    # pb <- txtProgressBar(min = 1, max = 8, style = 3)
    
    # ----- 1.0 Read data & Make time stamps ---------- Load the data
    
    vars.info <- data.frame(CF.name = c("air_temperature", "precipitation_flux", "air_temperature_max", 
                                        "air_temperature_min", "surface_downwelling_shortwave_flux_in_air", 
                                        "surface_downwelling_longwave_flux_in_air", "air_pressure", "specific_humidity", 
                                        "eastward_wind", "northward_wind", "wind_speed"))
    # Getting a list of all the available files and then subsetting to just the ones we 
    # actually want to use
    files.train <- dir(path.train)
    yrs.file <- strsplit(files.train, "[.]")
    yrs.file <- matrix(unlist(yrs.file), ncol=length(yrs.file[[1]]), byrow=T)
    yrs.file <- as.numeric(yrs.file[,ncol(yrs.file)-1]) # Assumes year is always last thing before the file extension
    
    if(!is.null(yrs.train)){
      files.train <- files.train[which(yrs.file %in% yrs.train)]
      yrs.file <- yrs.file[which(yrs.file %in% yrs.train)]
    }
    
    
    dat.train <- data.frame()
    for(i in 1:length(files.train)){
      yr.now <- yrs.file[i]
      
      ncT <- ncdf4::nc_open(file.path(path.train, files.train[i]))
      
      # Set up the time data frame to help index
      nday <- ifelse(lubridate::leap_year(yr.now), 366, 365)
      ntime <- length(ncT$dim$time$vals)
      step.day <- nday/ntime
      step.hr  <- step.day*24
      stamps.hr <- seq(step.hr/2, by=step.hr, length.out=1/step.day) # Time stamps centered on period
      
      # Create a data frame with all the important time info
      # center the hour step
      df.tmp <- data.frame(year=yr.now, doy=rep(1:nday, each=1/step.day), hour=rep(stamps.hr, nday))
      df.tmp$date <- strptime(paste(df.tmp$year, df.tmp$doy, df.tmp$hour, sep="-"), format=("%Y-%j-%H"), tz="UTC")
      
      # Extract the met info, making matrices with the appropriate number of ensemble members
      for(v in names(ncT$var)){
        df.tmp[,v] <- ncdf4::ncvar_get(ncT, v)
      }
      
      ncdf4::nc_close(ncT)
      
      dat.train <- rbind(dat.train, df.tmp)

      # setTxtProgressBar(pb, i)
    } # End looping through training data files
    
    if(!"wind_speed" %in% names(dat.train)){
      dat.train$wind_speed <- sqrt(dat.train$eastward_wind^2 + dat.train$northward_wind^2)
    }

    # # adding a temporary date variable for the model
    # if (dim$time$units == "sec"){
    #   sub_string<- substrRight(dat.train_file, 7)
    #   start_year <- substr(sub_string, 1, 4)
    #   dat.train$date <- as.Date((dim$time$vals/(dim$time$vals[2] - dim$time$vals[1])), 
    #                             tz="GMT", origin = paste0(start_year - 1, "-12-31"))
    # } else {
    #   start_year <- substr(dim$time$units,start = 12,stop = 15)
    #   dat.train$date = as.POSIXct(udunits2::ud.convert((dim$time$vals - ((dim$time$vals[2] - dim$time$vals[1])/2)),"days", "seconds"),
    #                               tz="GMT", origin = paste0(start_year, "-01-01 00:00:00"))
    # }

    # these non-standard variables help us organize our modeling approach
    # Reference everything off of the earliest date; avoiding 0s because that makes life difficult
    dat.train$sim.hr <- trunc(as.numeric(difftime(dat.train$date, min(dat.train$date), tz = "GMT", units = "hour")))+1
    dat.train$sim.day <- trunc(as.numeric(difftime(dat.train$date, min(dat.train$date), tz = "GMT", units = "day")))+1
    # dat.train$time.day2 <- as.integer(dat.train$time.day + 1/(48 * 2)) + 1  # Offset by half a time step to get time stamps to line up
    
    # ----- 1.1 Coming up with the daily means that are what we can
    # use as predictors ----------
    vars.use <- vars.info$CF.name[vars.info$CF.name %in% names(dat.train)]
    
    train.day <- aggregate(dat.train[, c("air_temperature", "precipitation_flux", 
        "surface_downwelling_shortwave_flux_in_air", "surface_downwelling_longwave_flux_in_air", 
        "air_pressure", "specific_humidity", "wind_speed")], by = dat.train[, 
        c("year", "doy")], FUN = mean)
    names(train.day)[3:9] <- c("air_temperature_mean.day", "precipitation_flux.day", 
        "surface_downwelling_shortwave_flux_in_air.day", "surface_downwelling_longwave_flux_in_air.day", 
        "air_pressure.day", "specific_humidity.day", "wind_speed.day")
    train.day$air_temperature_max.day <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy")], FUN = max)$x
    train.day$air_temperature_min.day <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy")], FUN = min)$x

    dat.train <- merge(dat.train[, ], train.day, all.x = T, all.y = T)

    # ----- 1.2 Setting up a 1-hour lag -- smooth transitions at
    # midnight NOTE: because we're filtering from the present back through
    # the past, -1 will associate the closest hour that we've already done
    # (midnight) with the day we're currently working on ----------
    vars.hour <- c("air_temperature", "precipitation_flux", "surface_downwelling_shortwave_flux_in_air", 
        "surface_downwelling_longwave_flux_in_air", "air_pressure", "specific_humidity", 
        "wind_speed")
    vars.lag <- c("lag.air_temperature", "lag.precipitation_flux", "lag.surface_downwelling_shortwave_flux_in_air", 
        "lag.surface_downwelling_longwave_flux_in_air", "lag.air_pressure", 
        "lag.specific_humidity", "lag.wind_speed")
    
    # Specifying what hour we want to lag
    # Note: For forward filtering, we want to associate today with tomorrow (+1 day) using the last observation of the day
    #       For backwards filtering, we want to associate today with yesterday (-1 day) using the first obs of the day
    met.lag <- ifelse(direction.filter=="backwards", -1, +1)
    lag.time <- ifelse(direction.filter=="backwards", min(dat.train$hour), max(dat.train$hour))
    
    # Pull out just the time we're interested in
    lag.day <- dat.train[dat.train$hour == lag.time, c("year", "doy", "sim.day", vars.hour)]
    names(lag.day)[4:ncol(lag.day)] <- vars.lag
    
    lag.day$lag.air_temperature_min <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy", "sim.day")], FUN = min)[, "x"]  # Add in a lag for the next day's min temp
    lag.day$lag.air_temperature_max <- aggregate(dat.train[, c("air_temperature")], 
        by = dat.train[, c("year", "doy", "sim.day")], FUN = max)[, "x"]  # Add in a lag for the next day's min temp
    lag.day$sim.day <- lag.day$sim.day + met.lag  # 
    
    
    dat.train <- merge(dat.train, lag.day[, c("sim.day", vars.lag, "lag.air_temperature_min", 
        "lag.air_temperature_max")], all.x = T)
    
    # ----- 1.3 Setting up a variable to 'preview' the next day's mean
    # to help get smoother transitions 
    # NOTE: If we're filtering forward in time, -1 will associate tomorrow with our downscaling
    #       for today
    # ----------
    vars.day <- c("air_temperature_mean.day", "air_temperature_max.day", 
        "air_temperature_mean.day", "precipitation_flux.day", "surface_downwelling_shortwave_flux_in_air.day", 
        "surface_downwelling_longwave_flux_in_air.day", "air_pressure.day", 
        "specific_humidity.day", "wind_speed.day")
    vars.next <- c("next.air_temperature_mean", "next.air_temperature_max", 
        "next.air_temperature_min", "next.precipitation_flux", "next.surface_downwelling_shortwave_flux_in_air", 
        "next.surface_downwelling_longwave_flux_in_air", "next.air_pressure", 
        "next.specific_humidity", "next.wind_speed")
    
    next.day <- dat.train[c("year", "doy", "sim.day", vars.day)]
    names(next.day)[4:ncol(next.day)] <- vars.next
    next.day <- aggregate(next.day[, vars.next], by = next.day[, c("year", "doy", "sim.day")], FUN = mean)
    next.day$sim.day <- next.day$sim.day - met.lag
    
    dat.train <- merge(dat.train, next.day[, c("sim.day", vars.next)], all.x = T)
    
    # ----- 1.4 calculate air_temperature_min & air_temperature_max as
    # departure from mean; order data ---------- Lookign at max & min as
    # departure from mean
    dat.train$max.dep <- dat.train$air_temperature_max.day - dat.train$air_temperature_mean.day
    dat.train$min.dep <- dat.train$air_temperature_min.day - dat.train$air_temperature_mean.day
    
    # ----- 2.1 Generating all the daily models, save the output as
    # .Rdata files, then clear memory Note: Could save Betas as .nc files
    # that we pull from as needed to save memory; but for now just leaving
    # it in the .Rdata file for eas Note: To avoid propogating too much
    # wonkiness in hourly data, any co-variates are at the daily level
    # Note: If mod.precipitation_flux.doy doesn't run, try increasing the
    # day.window for this variable. The lack of non-zero values makes it
    # difficult for the linear regression model to calculate coefficients
    # sometimes ---------

    temporal.downscale.functions(dat.train = dat.train, n.beta = n.beta, day.window = day.window, 
                                 resids = resids, n.cores = n.cores, 
                                 seed = seed, outfolder = outfolder) 
}

# Helper function
substrRight <- function(x, n) {
  substr(x, nchar(x) - n + 1, nchar(x))
}
