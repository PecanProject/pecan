##' Predict Subdaily Meteorology
##' Predict Subdaily Meteorology based off of statistics created in gen.subdaily.models()
# -----------------------------------
# Description
# -----------------------------------
##' @title predict_subdaily_met
##' @family tdm - Temporally Downscale Meteorology
##' @author Christy Rollinson, James Simkins
##' @description This is the main function of the tdm family workflow. This function predicts subdaily meteorology
##'              from daily means using a linear regression modeling approach. It takes a dataset with
##'              daily resolution and temporally downscales it to hourly resolution using the statistics
##'              generated by gen.subdaily.models(). It references the predict.subdaily.function
##'              located in lm_ensemble_sims() which uses a linear regression based approach to downscale.
##'              We generate multiple ensembles of possible hourly values dictated from the models and betas
##'              generated in gen.subdaily.models. Each ensemble member is saved as a netCDF file
##'              in CF conventions and these files are ready to be used in the general PEcAn workflow.
# -----------------------------------
# Parameters
# -----------------------------------
##' @param outfolder - directory where output file will be stored
##' @param in.path - path to model dataset you wish to temporally downscale
##' @param in.prefix - prefix of model dataset, i.e. if file is GFDL.CM3.rcp45.r1i1p1.2006 the prefix is 'GFDL.CM3.rcp45.r1i1p1'
##' @param dat.train_file - location of train_data file
##' @param lm.models.base - path to linear regression model folder from 3_gen_subdaily
##' @param start_date - yyyy-mm-dd
##' @param end_date - yyyy-mm-dd
##' @param n.ens - integer selecting number of hourly ensemble members
##' @param cores.max - 12
##' @param resids - logical stating whether to pass on residual data or not
##' @param parallel - logical stating whether to run temporal_downscale_functions.R in parallel
##' @param n.cores - deals with parallelization
##' @param overwrite
##' @param verbose
##' @export
##' @examples
##' \dontrun{
##' library(PEcAn.data.atmosphere)
##' outfolder = '~/Downscaled_GCM'
##' in.path = '~/raw_GCM'
##' in.prefix = 'GFDL'
##' lm.models.base = 'sf_scratch/US-WCr'
##' dat.train_file = 'Training_data/US-WCr_dat.train.nc'
##' start_date = '2010-01-01'
##' end_date = '2014-12-31'
##' cores.max = 12
##' n.ens = 3}
# -----------------------------------
#----------------------------------------------------------------------
# Begin Fcript
#----------------------------------------------------------------------

predict_subdaily_met <- function(outfolder, in.path, in.prefix, lm.models.base,
    dat.train_file, start_date, end_date, cores.max = 12,
    n.ens = 3, resids = FALSE, parallel = FALSE, n.cores = NULL,
    overwrite = FALSE, verbose = FALSE) {

    years <- seq(lubridate::year(start_date), lubridate::year(end_date))

    # Load the training dataset and make sure to pull in dimensions and
    # save as dim
    vars.info <- data.frame(CF.name = c("air_temperature", "precipitation_flux",
        "air_temperature_max", "air_temperature_min", "surface_downwelling_shortwave_flux_in_air",
        "surface_downwelling_longwave_flux_in_air", "air_pressure", "specific_humidity",
        "eastward_wind", "northward_wind", "wind_speed"))
    dat.train <- list()
    tem <- ncdf4::nc_open(dat.train_file)
    dim <- tem$dim
    lat.in <- dim$latitude$vals
    lon.in <- dim$longitude$vals
    for (j in seq_along(vars.info$CF.name)) {
        if (exists(as.character(vars.info$CF.name[j]), tem$var)) {
            dat.train[[j]] <- ncdf4::ncvar_get(tem, as.character(vars.info$CF.name[j]))
        } else {
            dat.train[[j]] <- NA
        }
    }
    names(dat.train) <- vars.info$CF.name
    dat.train <- data.frame(dat.train)

    # Create wind speed variable if it doesn't exist
    if (all(is.na(dat.train$wind_speed) == TRUE)) {
        dat.train$wind_speed <- sqrt(dat.train$eastward_wind^2 + dat.train$northward_wind^2)
    }

    # Create a date variable that will help us organize our workflow
    if (dim$time$units == "sec") {
        sub_string <- substrRight(dat.train_file, 7)
        start_year <- substr(sub_string, 1, 4)
        dat.train$date <- as.POSIXct(dim$time$vals, tz = "GMT", origin = paste0(start_year,
            "-01-01 ", udunits2::ud.convert(dim$time$vals[1], "seconds",
                "hour"), ":00:00"))
    } else {
        start_year <- substr(dim$time$units, start = 12, stop = 15)
        dat.train$date <- as.POSIXct(udunits2::ud.convert((dim$time$vals -
            ((dim$time$vals[2] - dim$time$vals[1])/2)), "days", "seconds"),
            tz = "GMT", origin = paste0(start_year, "-01-01 ", udunits2::ud.convert(dim$time$vals[1],
                "days", "hours"), ":00:00"))
    }

    dat.train$year <- lubridate::year(dat.train$date)
    dat.train$doy <- lubridate::yday(dat.train$date)
    dat.train$hour <- lubridate::hour(dat.train$date)

    df.hour <- data.frame(hour = unique(dat.train$hour))  # match this to whatever your 'hourly' timestep is

    # Set up the appropriate seed
    set.seed(format(Sys.time(), "%m%d"))
    seed.vec <- sample.int(1e+06, size = 500, replace = F)

    # Defining variable names, longname & units
    nc.info <- data.frame(CF.name = c("air_temperature", "precipitation_flux",
        "surface_downwelling_shortwave_flux_in_air", "surface_downwelling_longwave_flux_in_air",
        "air_pressure", "specific_humidity", "wind_speed"), longname = c("2 meter mean air temperature",
        "cumulative precipitation (water equivalent)", "incident (downwelling) showtwave radiation",
        "incident (downwelling) longwave radiation", "air_pressureure at the surface",
        "Specific humidity measured at the lowest level of the atmosphere",
        "Wind speed"), units = c("K", "kg m-2 s-1", "W m-2", "W m-2", "Pa",
        "kg kg-1", "m s-1"))
    # ----------------------------------
    for (y in years) {

        path.gcm <- file.path(in.path, paste0(in.prefix, ".", y, ".nc"))

        # ----------------------------------- 1. Format output so all ensemble
        # members can be run at once NOTE: Need to start with the last and work
        # to the first -----------------------------------

        # Read the lags
        nc.now <- ncdf4::nc_open(path.gcm)
        nc.time <- ncdf4::ncvar_get(nc.now, "time")

        for (j in seq_along(vars.info$CF.name)) {
            if (exists(as.character(vars.info$CF.name[j]), tem$var)) {
                lags.list[[j]] <- ncdf4::ncvar_get(nc.now, as.character(vars.info$CF.name[j]))
            } else {
                lags.list[[j]] <- NA
            }
        }
        names(lags.list) <- vars.info$CF.name
        lags.list <- data.frame(lags.list)

        # Define the lags.init list, the values that will initialize the entire
        # downscaling procedure
        lags.init <- list()
        for (v in vars.info$CF.name) {
            if (all(is.na(lags.list$air_temperature))) {
                lags.init[[v]] <- data.frame(array((dat.yr$air_temperature_max +
                                                      dat.yr$air_temperature_min)/2), dim = c(1, n.ens))
            }
            if (all(is.na(lags.list$wind_speed))) {
                lags.init[[v]] <- data.frame(array(sqrt((lags.list$eastward_wind^2) +
                  (lags.list$northward_wind^2)), dim = c(1, n.ens)))
            } else {
                lags.init[[v]] <- data.frame(array(lags.list[[v]], dim = c(1,
                  n.ens)))
            }
        }


        # Now we read in the data we wish to downscale and leave it as is
        dat.ens <- list()  # a new list for each ensemble member as a new layer
        ens.sims <- list()  # this will propogate that spread through each year, so instead of
        # restarting every January 1, it will propogate those lag values

        # Create a list layer for each ensemble member
        dat.yr <- list()
        nc.now <- ncdf4::nc_open(path.gcm)
        dim <- nc.now$dim
        for (j in seq_along(vars.info$CF.name)) {
            if (exists(as.character(vars.info$CF.name[j]), tem$var)) {
                dat.yr[[j]] <- ncdf4::ncvar_get(nc.now, as.character(vars.info$CF.name[j]))
            } else {
                dat.yr[[j]] <- NA
            }
        }
        names(dat.yr) <- vars.info$CF.name
        dat.yr <- data.frame(dat.yr)

        # We need to fill these variables if they aren't available
        if (all(is.na(dat.yr$air_temperature))) {
            dat.yr$air_temperature <- ((dat.yr$air_temperature_max + dat.yr$air_temperature_min)/2)
        }
        if (all(is.na(dat.yr$wind_speed))) {
            dat.yr$wind_speed <- sqrt(dat.yr$eastward_wind^2 + dat.yr$northward_wind^2)
        }
        ncdf4::nc_close(nc.now)

        # We need to create a date variable to help us organize everything
        dat.yr$year <- y
        if (dim$time$units == "sec") {
            dat.yr$date <- as.Date((dim$time$vals/(dim$time$vals[2] - dim$time$vals[1])),
                tz = "GMT", origin = paste0(y - 1, "-12-31"))
        }
        if (dim$time$units == paste0("days since ", y, "-01-01T00:00:00Z")) {
            dat.train$date <- as.POSIXct(udunits2::ud.convert((dim$time$vals -
                ((dim$time$vals[2] - dim$time$vals[1])/2)), "days", "seconds"),
                tz = "GMT", origin = paste0(y, "-01-01 00:00:00"))
        }
        dat.yr$doy <- lubridate::yday(dat.yr$date)

        # Create the data frame for the 'next' values
        dat.nxt <- dat.yr
        # Shift everyting up by a day to get the preview of the next day
        dat.nxt[2:(nrow(dat.nxt)), c("air_temperature_max", "air_temperature_min",
            "precipitation_flux", "surface_downwelling_shortwave_flux_in_air",
            "surface_downwelling_longwave_flux_in_air", "air_pressure",
            "specific_humidity", "wind_speed")] <- dat.nxt[1:(nrow(dat.nxt) -
            1), c("air_temperature_max", "air_temperature_min", "precipitation_flux",
            "surface_downwelling_shortwave_flux_in_air", "surface_downwelling_longwave_flux_in_air",
            "air_pressure", "specific_humidity", "wind_speed")]

        # Need to add in the 'next' value Note: if we're past the end of our
        # daily data, the best we can do is leave things as is (copy the last
        # day's value)
        if (y < max(years)) {

            path.gcm <- file.path(in.path, paste0(in.prefix, ".", y + 1,
                ".nc"))
            nc.nxt <- ncdf4::nc_open(path.gcm)

            dat.nxt$time <- ncdf4::ncvar_get(nc.nxt, "time")
            for (j in vars.info$CF.name) {
                dat.nxt[dat.nxt$time == max(dat.nxt$time), j] <- ncdf4::ncvar_get(nc.nxt,
                  j)[length(nxt.time)]
            }
            ncdf4::nc_close(nc.nxt)
        }

        # Now we put everything into 1 main data.frame
        dat.ens <- data.frame(year = dat.yr$year, doy = dat.yr$doy, date = dat.yr$date,
            air_temperature_max.day = dat.yr$air_temperature_max, air_temperature_min.day = dat.yr$air_temperature_min,
            precipitation_flux.day = dat.yr$precipitation_flux, surface_downwelling_shortwave_flux_in_air.day = dat.yr$surface_downwelling_shortwave_flux_in_air,
            surface_downwelling_longwave_flux_in_air.day = dat.yr$surface_downwelling_longwave_flux_in_air,
            air_pressure.day = dat.yr$air_pressure, specific_humidity.day = dat.yr$specific_humidity,
            wind_speed.day = dat.yr$wind_speed, next.air_temperature_max = dat.nxt$air_temperature_max,
            next.air_temperature_min = dat.nxt$air_temperature_min, next.precipitation_flux = dat.nxt$precipitation_flux,
            next.surface_downwelling_shortwave_flux_in_air = dat.nxt$surface_downwelling_shortwave_flux_in_air,
            next.surface_downwelling_longwave_flux_in_air = dat.nxt$surface_downwelling_longwave_flux_in_air,
            next.air_pressure = dat.nxt$air_pressure, next.specific_humidity = dat.nxt$specific_humidity,
            next.wind_speed = dat.nxt$wind_speed)

        dat.ens$time.day <- as.numeric(difftime(dat.ens$date, paste0(y -
            1, "-12-31"), tz = "GMT", units = "day"))
        dat.ens <- merge(dat.ens, df.hour, all = T)

        dat.ens$date <- strptime(paste(dat.ens$year, dat.ens$doy, dat.ens$hour,
            sep = "-"), "%Y-%j-%H", tz = "GMT")
        dat.ens$time.hr <- as.numeric(difftime(dat.ens$date, paste0(y -
            1, "-12-31"), tz = "GMT", units = "hour"))  #+ minute(dat.train$date)/60
        dat.ens <- dat.ens[order(dat.ens$time.hr), ]

        # ----------------------------------- 2. Predict met vars for each
        # ensemble member Note: Using a loop for each ensemble member for now,
        # but this will get parallelized to speed it up soon, but we'll
        # prototype in parallel -----------------------------------

        ens.sims <- lm_ensemble_sims(dat.ens, n.ens = n.ens,
            path.model = file.path(lm.models.base), lags.list = NULL, lags.init = lags.init,
            dat.train = dat.train)

        # Set up the time dimension for this year
        hrs.now <- as.numeric(difftime(dat.ens$date, paste0(y, "-01-01"),
            tz = "GMT", units = "hour"))

        for (v in names(ens.sims)) {
            lags.init[[v]] <- data.frame(ens.sims[[v]][length(ens.sims[[v]]),
                ])
        }

        # Write each year for each ensemble member into its own .nc file
        lat <- ncdf4::ncdim_def(name = "latitude", units = "degree_north",
            vals = lat.in, create_dimvar = TRUE)
        lon <- ncdf4::ncdim_def(name = "longitude", units = "degree_east",
            vals = lon.in, create_dimvar = TRUE)

        ntime <- nrow(dat.ens)
        diy <- PEcAn.utils::days_in_year(y)
        days_elapsed <- (seq_len(ntime) * diy / ntime) - (0.5 * diy / ntime)
        time <- ncdf4::ncdim_def(name = "time", units = paste0("days since ",
            y, "-01-01T00:00:00Z"), vals = as.array(days_elapsed), create_dimvar = TRUE,
            unlim = TRUE)

        dim <- list(lat, lon, time)

        var.list <- list()
        for (j in seq_along(nc.info$CF.name)) {
            var.list[[j]] <- ncdf4::ncvar_def(name = as.character(nc.info$CF.name[j]),
                units = as.character(nc.info$units[j]), dim = dim, missval = -9999,
                verbose = verbose)
        }

        for (i in seq_len(n.ens)) {
            df <- data.frame(matrix(ncol = length(nc.info$name), nrow = nrow(dat.ens)))
            colnames(df) <- nc.info$name
            for (j in nc.info$CF.name) {
                ens.sims[[j]][["X1"]]
                e <- paste0("X", i)
                df[[j]] <- ens.sims[[j]][[e]]
            }

            df <- df[, c("air_temperature", "precipitation_flux", "surface_downwelling_shortwave_flux_in_air",
                "surface_downwelling_longwave_flux_in_air", "air_pressure",
                "specific_humidity", "wind_speed")]
            colnames(df) <- nc.info$CF.name

            dir.create(outfolder, showWarnings = FALSE, recursive = TRUE)
            loc.file <- file.path(outfolder, paste0(in.prefix, "_ens",
                i, "_", y, ".nc"))
            loc <- ncdf4::nc_create(filename = loc.file, vars = var.list,
                verbose = verbose)

            for (j in nc.info$CF.name) {
                ncdf4::ncvar_put(nc = loc, varid = as.character(j), vals = df[[j]][seq_len(nrow(df))])
            }
            ncdf4::nc_close(loc)
        }
        print(paste0("finished year ", y))

    }
}
