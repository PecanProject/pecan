## ensures data.table objects treated as such
## http://stackoverflow.com/q/24501245/513006
.datatable.aware=TRUE

##' Temporal downscaling of daily or subdaily met data
##'
##' @title Downscale CF met data
##' @param cfmet data.table with CF variables generated by \code{\link{load.cfmet}}  
##' @param output.dt time step (hours) for output
##' @return downscaled result
##' @export
##' @author David LeBauer
cfmet.downscale.time <- cruncep_hourly <- function(cfmet, output.dt = 1, lat = lat, ...){

  ## time step
  dt_hr <- as.numeric(round(difftime(cfmet$date[2], cfmet$date[1],  units = "hours")))
  
  if (dt_hr == output.dt) {
    downscaled.result <- cfmet
  }
  
  if("specific_humidity" %in% colnames(cfmet) & (!"relative_humidity" %in% colnames(cfmet))){
    cfmet$relative_humidity <- cfmet[,list(qair2rh(qair = specific_humidity, 
                                                   temp = ud.convert(air_temperature, "Kelvin", "Celsius"), 
                                                   press = air_pressure))]
  }
  
  if(dt_hr > output.dt & dt_hr <= 6) {
    downscaled.result <- cfmet.downscale.subdaily(subdailymet = cfmet, output.dt = output.dt)
  } else if(dt_hr > 6 & dt_hr < 24){
#     cfmet <- cfmet[,list(air_temperature_max = max(air_temperature),
#                          air_temperature_min = min(air_temperature),
#                          ), by = 'year,doy'])
#    dt_hr <- 24
    logger.error("timestep of input met data is between 6 and 24 hours.\n",
                "PEcAn will automatically convert this to daily data\n",
                "you should confirm validity of downscaling, in particular that min / max temperatures are realistic")
  }
  
  if (dt_hr == 24) {
    if(all(c("tmax", "tmin") %in% colnames(cfmet))){
      setnames(cfmet, c("tmax", "tmin"), c("air_temperature_max", "air_temperature_min"))      
    }
    downscaled.result <- cfmet.downscale.daily(dailymet = cfmet, output.dt = output.dt, lat = lat)
  } else if(dt_hr > 24){
    logger.error("only daily and sub-daily downscaling supported")
  }
   
  return(downscaled.result)
}


##' Subdaily to hourly (or less) downscaling
##'
##' Uses simple spline to interpolate variables with diurnal variability, otherwise uses averaging or repeating
##' for variables with no clear diurnal pattern. For all variables except temperature, negative values are set to zero.
##' @title subdaily downscaling
##' @param subdailymet data table with climate variables queried from \code{\link{load.cfmet}}
##' @param output.dt output timestep. default is one hour
##' @export
##' @return weather file for input to BioGro and related crop growth functions
##' @author David LeBauer
cfmet.downscale.subdaily <- function(subdailymet, output.dt = 1){
  ## converting surface_downwelling_shortwave_flux_in_air from W/m2 avg to PPFD
  new.date <- subdailymet[,list(hour = 0:(23 / output.dt) / output.dt),
                    by = c("year", "month", "day", "doy")]
  
  new.date$date <- new.date[,list(date = ymd(paste(year, month, day)) + hours(hour))]
  
  downscaled.result <- list()
  tint <- nrow(new.date)/ nrow(subdailymet)
  if(all(c("eastward_wind", "nortward_wind") %in% colnames(subdailymet))){
    downscaled.result[["northward_wind"]] <- rep(subdailymet$northward_wind, each = tint)
    downscaled.result[["eastward_wind"]]  <- rep(subdailymet$eastward_wind, each = tint)   
    if(!"wind_speed" %in% colnames(subdailymet)){
      wind_speed <- sqrt(northward_wind^2 + eastward_wind^2)     
    }
  }
  downscaled.result[["wind_speed"]] <- rep(subdailymet$wind_speed, each = tint)
  
  solarMJ <- ud.convert(subdailymet$surface_downwelling_shortwave_flux_in_air, paste0("W ", tint, "h"), "MJ" )
  PAR <- 0.486 * solarMJ ## Cambell and Norman 1998 p 151, ch 10
  subdailymet$ppfd <- ud.convert(PAR, "mol s", "micromol h")
  downscaled.result[["ppfd"]] <- subdailymet$ppfd  

  downscaled.result[["surface_downwelling_shortwave_flux_in_air"]] <- subdailymet$surface_downwelling_shortwave_flux_in_air 

  
  for(var in c("air_pressure", "specific_humidity",
               "precipitation_flux", "air_temperature", "northward_wind", "eastward_wind", "surface_downwelling_shortwave_flux_in_air", "ppfd")){
    if(var %in% colnames(subdailymet)){
      ## convert units from subdaily to hourly
      hrscale <- ifelse(var %in%
                          c("surface_downwelling_shortwave_flux_in_air",
                            "precipitation_flux"),
                        output.dt, 1)
      
      f <- splinefun(as.numeric(subdailymet$date), (subdailymet[[var]] / hrscale), method = "monoH.FC")
      downscaled.result[[var]] <- f(as.numeric(new.date$date))
      if(!var == "air_temperature"){
        downscaled.result[[var]][downscaled.result[[var]] < 0] <- 0
      }
    }
    
  }
  
  
  downscaled.result <- cbind(new.date, as.data.table(downscaled.result))
  
}

##' Simple, Fast Daily to Hourly Climate Downscaling
##'
##' Based on weach family of functions but 5x faster than weachNEW,
##' and requiring metric units (temperature in celsius, windspeed in kph,
##' precip in mm, relative humidity as fraction). 
##' Derived from the weachDT function in the BioCro package.
##' @title daily to subdaily downscaling
##' @param dailymet data table with climate variables
##' @param lat latitude (for calculating solar radiation)
##' @param output.dt output timestep
##' @export
##' @return weather file for input to BioGro and related crop / ecosystem models
##' @author David LeBauer
cfmet.downscale.daily <- weachDT <- function(dailymet, output.dt = 1, lat){
  
  tint <- 24 / output.dt
  tseq <- 0:(23 * output.dt) / output.dt

  setkeyv(dailymet, c("year", "doy"))
  
  if(all(c("air_temperature_max", "air_temperature_min") %in% colnames(dailymet))){
    setnames(dailymet, c("air_temperature_max", "air_temperature_min"), c("tmax", "tmin")) 
  }

  light <- dailymet[,lightME(DOY = doy, t.d = tseq, lat = lat),
                    by = c("year", "doy")]
  
  light$Itot <- light[,list(I.dir + I.diff)]
  resC2 <- light[, list(resC2 = (Itot - min(Itot)) / max(Itot)), by = c("year", "doy")]$resC2
  solarR <- dailymet[,list(year, doy, 
                           solarR = rep(surface_downwelling_shortwave_flux_in_air * 2.07 * 10^5 /36000, each = tint) * resC2)]
  
  SolarR <- cbind(resC2, solarR)[,list(SolarR = solarR * resC2)]$SolarR
  
  ## Temperature
  Temp <- dailymet[,list(Temp = tmin + (sin(2*pi*(tseq-10)/tint) + 1)/2 * (tmax - tmin), hour = tseq),
                   by = 'year,doy']$Temp
  
  ## Relative Humidity
  RH <-   dailymet[,list(RH = rep(relative_humidity, each = tint), hour = tseq), by = 'year,doy']
  setkeyv(RH, c('year','doy','hour'))  
  
 # if(!"air_pressure" %in% colnames(dailymet)) air_pressure <- 
  qair <- dailymet[,list(year, doy, tmin, tmax, air_pressure,
                         air_temperature,
                         qmin = rh2qair(rh = relative_humidity/100, T = tmin),
                         qmax = rh2qair(rh = relative_humidity/100, T =tmax))]
  
  a <- qair[,list(year, doy, tmin, tmax, air_temperature, qmin, qmax, pressure = ud.convert(air_pressure, "Pa", "millibar"))][ ,list(year, doy, rhmin = qair2rh(qmin, air_temperature, pressure),       rhmax = qair2rh(qmax, air_temperature, pressure))]
  rhscale <- (cos(2 * pi * (tseq - 10)/tint) + 1)/2
  RH <- a[, list(RH = rhmin + rhscale * (rhmax - rhmin)), by = c("year", "doy")]$RH

 ## Wind Speed


 if("wind_speed" %in% colnames(dailymet)){
   wind_speed <- rep(dailymet$wind_speed, each = tint)
 } else if(all(c("eastward_wind", "northward_wind") %in% colnames(dailymet))){
   northward_wind <- rep(dailymet$northward_wind, each = tint)
   eastward_wind <- rep(dailymet$eastward_wind, each = tint)   
   if(!"wind_speed" %in% colnames(dailymet)){
     wind_speed <- sqrt(northward_wind^2 + eastward_wind^2)     
   }
 } else {
   logger.error("no wind_speed found in daily met dataset")
 }

  ## Precipitation
  precip <- rep(dailymet$precipitation_flux / tint, each = tint)
  
  ## Hour
  time <- dailymet[,list(hour = tseq), by = c("year", "doy")]
  
  ans <- data.table(time,
                    downwelling_photosynthetic_photon_flux = SolarR,
                    air_temperature = ud.convert(Temp, "kelvin", "celsius"), 
                    relative_humidity = RH,
                    wind = wind_speed,
                    precipitation_flux = precip)
  return(ans)
}

##' Get time series vector from netCDF file
##'
##' internal convenience function for
##' streamlining extraction of data from netCDF files
##' with CF-compliant variable names
##' 
##' @title Get time series vector from netCDF file
##' @param var 
##' @param lati 
##' @param loni 
##' @param run.dates 
##' @param met.nc netcdf file with CF variable names
##' @return numeric vector
##' @export
##' @author David Shaner LeBauer
get.ncvector <- function(var, lati = lati, loni = loni,
                         run.dates = run.dates, met.nc){
  
  start.idx = c(latitude = lati, longitude = loni, time = run.dates$index[1])
  count.idx = c(latitude = 1, longitude = 1, time = nrow(run.dates))
  dim.order <- sapply(met.nc$var$air_temperature$dim, function(x) x$name)
  ncvar_get2 <- function(var){
    ans <-  ncvar_get(nc = met.nc, varid = var,
                      start = start.idx[dim.order],
                      count = count.idx[dim.order])
    return(as.numeric(ans))
  }
  
  if(var %in% attributes(met.nc$var)$names){
    ans <- ncvar_get2(var)
  } else if (var == "air_pressure"){
    ans <- 1013.25
  } else if (var == "wind"){
    ans <- sqrt(ncvar_get2("northward_wind")^2 + ncvar_get2("eastward_wind")^2)
  } else {
    ans <- NULL
  } 
  
  if (var == "precipitation_flux"){
    precip_units <- met.nc$var[["precipitation_flux"]]$units
    precip_units <- gsub("kg m-2", "mm", precip_units)
    precip_units <- gsub("kg/m2", "mm", precip_units)
    ans <- ud.convert(ans, precip_units, "mm s-1")
    
  }
  return(ans)
}
