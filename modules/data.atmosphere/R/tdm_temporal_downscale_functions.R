##' Temporal Downscale Functions
##'  Met variable functions that are called in gen.subdaily.models and predict.subdaily.workflow
# ----------------------------------- 
# Description
# -----------------------------------
##' @title temporal_downscale_functions
##' @family tdm - Temporally Downscale Meteorology
##' @author Christy Rollinson, James Simkins
##' @description This function contains the functions that do the heavy lifting in gen.subdaily.models()
##'              and predict.subdaily.workflow(). Individual variable functions actually generate the models 
##'              and betas from the dat.train_file and save them in the output file. save.model() and 
##'              save.betas() are helper functions that save the linear regression model output to a 
##'              specific location. In the future, we should only save the data that we actually use from the 
##'              linear regression model because this is a large file. predict.met() is called from
##'              predict.subdaily.workflow() and references the linear regression model output to 
##'              predict the ensemble data. 
# ----------------------------------- 
# Parameters
# -----------------------------------
##' @param dat.train - training data generated by tdm_nc2dat.train.R
##' @param n.beta - number of betas to generate
##' @param path.out - path to where the training models & betas will be stored
##' @param resids - whether or not to propogate residuals, set to FALSE
##' @param parallel - whether or not to run in parallel. this is a feature
##'                   still being worked on, set to FALSE
##' @param n.cores - number of cores to use parallel processing on, set to NULL
##' @param day.window - number of days surrounding current day we want to pull
##'                     statistics from
##' @param seed - allows this to be reproducible
##' @export
# -----------------------------------
#----------------------------------------------------------------------
# Begin Function
#----------------------------------------------------------------------
temporal.downscale.functions <- function(dat.train, n.beta, day.window, 
    resids = FALSE, parallel = FALSE, n.cores = NULL, seed = format(Sys.time(), 
        "%m%d"), outfolder, in.prefix, ...) {
    
    pb.index <- 1
    pb <- txtProgressBar(min = 1, max = 8, style = 3)
    setTxtProgressBar(pb, pb.index)
    
    # Declare the variables of interest that will be called in the
    # overarching loop
    vars.list <- list("surface_downwelling_shortwave_flux_in_air", "air_temperature", 
        "precipitation_flux", "surface_downwelling_longwave_flux_in_air", 
        "air_pressure", "specific_humidity", "wind_speed")
    
    # Data info that will be used to help organize dataframe for
    # downscaling
    dat.info <- c("time.day", "year", "doy", "hour", "air_temperature_max.day", 
        "air_temperature_min.day", "precipitation_flux.day", "surface_downwelling_shortwave_flux_in_air.day", 
        "surface_downwelling_longwave_flux_in_air.day", "air_pressure.day", 
        "specific_humidity.day", "wind_speed.day", "next.air_temperature_max", 
        "next.air_temperature_min", "next.precipitation_flux", "next.surface_downwelling_shortwave_flux_in_air", 
        "next.surface_downwelling_longwave_flux_in_air", "next.air_pressure", 
        "next.specific_humidity", "next.wind_speed")
    
    # ------ Beginning of Downscaling For Loop
    
    for (v in vars.list) {
        
        # Define the path
        path.out <- paste0(outfolder, "/",in.prefix, "/", v)
        
        # Set our seed
        set.seed(seed)
        if (!dir.exists(path.out)) 
            dir.create(path.out, recursive = T)

        # Create empty lists
        dat.list <- list()
        mod.out <- list()
        
        # Utilize window days for insufficient datasets
        for (i in unique(dat.train$doy)) {
            if (i >= 365) {
                # Lump leap day in with non-leap Dec 31
                dat.list[[paste(i)]] <- dat.train[dat.train$doy >= 365 - 
                  day.window/2 | dat.train$doy <= day.window/2, ]
            } else if (i == 1) {
                dat.list[[paste(i)]] <- dat.train[dat.train$doy <= i + 
                  day.window/2 | dat.train$doy >= 365 - day.window/2, ]
            } else {
                dat.list[[paste(i)]] <- dat.train[dat.train$doy >= i - 
                  day.window/2 & dat.train$doy <= i + day.window/2, ]
            }
        }
        
        
        # ----- generate the mod.out file
        if (parallel) {
            warning("Running model calculation in parallel.  This WILL crash if you do not have access to a LOT of memory!")
            
            if (v == "surface_downwelling_shortwave_flux_in_air") {
                mod.out <- parallel::mclapply(dat.list, model.train, mc.cores = n.cores, 
                  n.beta = n.beta, resids = resids, threshold = quantile(dat.train[dat.train$surface_downwelling_shortwave_flux_in_air > 
                    0, "surface_downwelling_shortwave_flux_in_air"], 0.05))
            } else {
                mod.out <- parallel::mclapply(dat.list, model.train, mc.cores = n.cores, 
                  n.beta = n.beta, resids = resids)
            }
            
            
            
            # Use a loop to sace each day of year independently
            for (i in names(mod.out)) {
                # Save the betas as .nc
                outfile <- file.path(path.out, paste0("betas_", v, "_", 
                  i, ".nc"))
                dimY <- ncdf4::ncdim_def(paste0("coeffs_", i), units = "unitless", 
                  longname = "model.out coefficients", vals = 1:ncol(mod.out[[i]][["betas"]]))
                dimX <- ncdf4::ncdim_def("random", units = "unitless", 
                  longname = "random betas", vals = 1:nrow(mod.out[[i]][["betas"]]))
                var.list <- ncdf4::ncvar_def(i, units = "coefficients", 
                  dim = list(dimX, dimY), longname = paste0("day ", i, 
                    " model.out coefficients"))
                nc <- ncdf4::nc_create(outfile, var.list)
                ncdf4::ncvar_put(nc, var.list, mod.out[[i]][["betas"]])
                ncdf4::nc_close(nc)
                
                # Save the model as a .Rdata
                mod.save <- mod.out[[i]][["model"]]
                save(mod.save, file = file.path(path.out, paste0("model_", 
                  v, "_", i, ".Rdata")))
            }
            
        } else {
            for (i in names(dat.list)) {
                
                if (v == "surface_downwelling_shortwave_flux_in_air") {
                  mod.out <- model.train(dat.subset = dat.list[[i]], n.beta = n.beta, v = v, threshold = quantile(dat.train[dat.train$surface_downwelling_shortwave_flux_in_air > 
                    0, "surface_downwelling_shortwave_flux_in_air"], 0.05), 
                    n.beta, resids = resids)
                } else {
                  mod.out <- model.train(dat.subset = dat.list[[i]], n.beta = n.beta, v = v,
                    resids = resids)
                }
                
                
                # Save the betas as .nc
                outfile <- file.path(path.out, paste0("betas_", v, "_", 
                  i, ".nc"))
                dimY <- ncdf4::ncdim_def(paste0("coeffs_", i), units = "unitless", 
                  longname = "model.out coefficients", vals = 1:ncol(mod.out[["betas"]]))
                dimX <- ncdf4::ncdim_def("random", units = "unitless", 
                  longname = "random betas", vals = 1:nrow(mod.out[["betas"]]))
                var.list <- ncdf4::ncvar_def(i, units = "coefficients", 
                  dim = list(dimX, dimY), longname = paste0("day ", i, 
                    " model.out coefficients"))
                nc <- ncdf4::nc_create(outfile, var.list)
                ncdf4::ncvar_put(nc, var.list, mod.out[["betas"]])
                ncdf4::nc_close(nc)
                
                # Save the model as a .Rdata
                mod.save <- mod.out$mode
                save(mod.save, file = file.path(path.out, paste0("model_", 
                  v, "_", i, ".Rdata")))
            }
        }
        
        pb.index <- pb.index + 1
        setTxtProgressBar(pb, pb.index)
    }  # end of the variable for loop
    
}  # end of the function





