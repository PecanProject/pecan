##' Temporal Downscale Functions
##'  Met variable functions that are called in gen.subdaily.models and predict.subdaily.workflow
# ----------------------------------- 
# Description
# -----------------------------------
##' @title temporal_downscale_functions
##' @family tdm - Temporally Downscale Meteorology
##' @author Christy Rollinson, James Simkins
##' @description This function contains the functions that do the heavy lifting in gen.subdaily.models()
##'              and predict.subdaily.workflow(). Individual variable functions actually generate the models 
##'              and betas from the dat.train_file and save them in the output file. save.model() and 
##'              save.betas() are helper functions that save the linear regression model output to a 
##'              specific location. In the future, we should only save the data that we actually use from the 
##'              linear regression model because this is a large file. predict.met() is called from
##'              predict.subdaily.workflow() and references the linear regression model output to 
##'              predict the ensemble data. 
# ----------------------------------- 
# Parameters
# -----------------------------------
##' @param dat.train - training data generated by tdm_nc2dat.train.R
##' @param n.beta - number of betas to generate
##' @param resids - whether or not to propogate residuals, set to FALSE
##' @param parallel - whether or not to run in parallel. this is a feature
##'                   still being worked on, set to FALSE
##' @param n.cores - number of cores to use parallel processing on, set to NULL
##' @param day.window - number of days surrounding current day we want to pull
##'                     statistics from
##' @param seed - allows this to be reproducible
##' @param outfolder = where the output should be stored
##' @param print.progress - print progress of model generation?
##' @export
# -----------------------------------
#----------------------------------------------------------------------
# Begin Function
#----------------------------------------------------------------------
temporal.downscale.functions <- function(dat.train, n.beta, day.window, 
    resids = FALSE, parallel = FALSE, n.cores = NULL, seed = format(Sys.time(), "%m%d"), outfolder, print.progress=FALSE, ...) {
    
    if(print.progress==TRUE){
      pb.index <- 1
      pb <- utils::txtProgressBar(min = 1, max = 8, style = 3)
      utils::setTxtProgressBar(pb, pb.index)
    }
    # Declare the variables of interest that will be called in the
    # overarching loop
    vars.list <- c("surface_downwelling_shortwave_flux_in_air", "air_temperature", 
        "precipitation_flux", "surface_downwelling_longwave_flux_in_air", 
        "air_pressure", "specific_humidity", "wind_speed")
    
    # Data info that will be used to help organize dataframe for
    # downscaling
    dat.info <- c("time.day", "year", "doy", "hour", "air_temperature_max.day", 
        "air_temperature_min.day", "precipitation_flux.day", "surface_downwelling_shortwave_flux_in_air.day", 
        "surface_downwelling_longwave_flux_in_air.day", "air_pressure.day", 
        "specific_humidity.day", "wind_speed.day", "next.air_temperature_max", 
        "next.air_temperature_min", "next.precipitation_flux", "next.surface_downwelling_shortwave_flux_in_air", 
        "next.surface_downwelling_longwave_flux_in_air", "next.air_pressure", 
        "next.specific_humidity", "next.wind_speed")
    
    # ------ Beginning of Downscaling For Loop
    
    for (v in vars.list) {
        
        # Define the path
        path.out <- file.path(outfolder, v)
        if (!dir.exists(path.out)) dir.create(path.out, recursive = T)
        
        # Set our seed
        set.seed(seed)

        # Create empty lists
        dat.list <- list()
        mod.out <- list()
        
        # Utilize window days for insufficient datasets
        for (i in unique(dat.train$doy)) {
            if (i >= 365) {
                # Lump leap day in with non-leap Dec 31
                dat.list[[paste(i)]] <- dat.train[dat.train$doy >= 365 - 
                  day.window/2 | dat.train$doy <= day.window/2, ]
            } else if (i == 1) {
                dat.list[[paste(i)]] <- dat.train[dat.train$doy <= i + 
                  day.window/2 | dat.train$doy >= 365 - day.window/2, ]
            } else {
                dat.list[[paste(i)]] <- dat.train[dat.train$doy >= i - 
                  day.window/2 & dat.train$doy <= i + day.window/2, ]
            }
        }
        
        
        # ----- generate the mod.out file
        if (parallel) {
          warning("Running model calculation in parallel.  This will probably crash if you do not have access to a LOT of memory!")
          if (! requireNamespace("parallel", quietly = TRUE)) {
            PEcAn.logger::logger.severe(
              "Cannot find package 'parallel', ",
              "which is needed for parallel model calculations. ",
              "Either set parallel = FALSE, ",
              "or run 'install.packages(\"parallel\")' and try again.")
          }
          
          if (v == "surface_downwelling_shortwave_flux_in_air") {
              mod.out <- parallel::mclapply(dat.list, model.train, mc.cores = n.cores, 
                n.beta = n.beta, resids = resids, threshold = quantile(dat.train[dat.train$surface_downwelling_shortwave_flux_in_air > 
                  0, "surface_downwelling_shortwave_flux_in_air"], 0.05))
          } else {
              mod.out <- parallel::mclapply(dat.list, model.train, mc.cores = n.cores, 
                n.beta = n.beta, resids = resids)
          }
          
          
            
          # Use a loop to save each day of year independently
          for (i in names(mod.out)) {
              # Save the betas as .nc
              outfile <- file.path(path.out, paste0("betas_", v, "_", 
                i, ".nc"))
              dimY <- ncdf4::ncdim_def(paste0("coeffs_", i), units = "unitless", 
                longname = "model.out coefficients", vals = 1:ncol(mod.out[[i]][["betas"]]))
              dimX <- ncdf4::ncdim_def("random", units = "unitless", 
                longname = "random betas", vals = 1:nrow(mod.out[[i]][["betas"]]))
              var.list <- ncdf4::ncvar_def(i, units = "coefficients", 
                dim = list(dimX, dimY), longname = paste0("day ", i, 
                  " model.out coefficients"))
              nc <- ncdf4::nc_create(outfile, var.list)
              ncdf4::ncvar_put(nc, var.list, mod.out[[i]][["betas"]])
              ncdf4::nc_close(nc)
              
              # Save the model as a .Rdata
              mod.save <- list()
		        	mod.save$call  <- mod.out[[i]]$model$call
      				mod.save$coef  <- coef(mod.out[[i]]$model)
      				mod.save$formula <- parse(text=mod.out[[i]]$model$call[[2]][c(1,3)])
      				mod.save$factors  <- rownames(attr(mod.out[[i]]$model$terms, "factors"))
      				mod.save$xlev  <- mod.out[[i]]$model$xlevels
      				mod.save$contr <- mod.out[[i]]$model$contrasts
              save(mod.save, file = file.path(path.out, paste0("model_", 
                v, "_", i, ".Rdata")))
                
              if(resids) {
      					# Save the betas as .nc
      					outfile <- file.path(path.out, paste0("resids_betas_", v, "_", 
      					  i, ".nc"))
      					dimY <- ncdf4::ncdim_def(paste0("coeffs_", i), units = "unitless", 
      					  longname = "model.out coefficients", vals = 1:ncol(mod.out[[i]][["betas.resid"]]))
      					dimX <- ncdf4::ncdim_def("random", units = "unitless", 
      					  longname = "random betas", vals = 1:nrow(mod.out[[i]][["betas.resid"]]))
      					var.list <- ncdf4::ncvar_def(i, units = "coefficients", 
      					  dim = list(dimX, dimY), longname = paste0("day ", i, 
      						"resid model.out coefficients"))
      					nc <- ncdf4::nc_create(outfile, var.list)
      					ncdf4::ncvar_put(nc, var.list, mod.out[[i]][["betas.resid"]])
      					ncdf4::nc_close(nc)
      				
      					# Save the model as a .Rdata
      					mod.save <- list()
      					mod.save$call  <- mod.out[[i]]$model.resid$call
      					mod.save$coef  <- coef(mod.out[[i]]$model.resid)
      					mod.save$formula <- parse(text=mod.out[[i]]$model.resid$call[[2]][c(1,3)])
      					mod.save$factors  <- rownames(attr(mod.out[[i]]$model.resid$terms, "factors"))
      					mod.save$xlev  <- mod.out[[i]]$model.resid$xlevels
      					mod.save$contr <- mod.out[[i]]$model.resid$contrasts
      					save(mod.save, file = file.path(path.out, paste0("resids_model_", 
      					  v, "_", i, ".Rdata")))
            } # End resids case
          } # End save loop

        } else { # Doing this is series
            for (i in names(dat.list)) {
                
              if (v == "surface_downwelling_shortwave_flux_in_air") {
                mod.out <- model.train(dat.subset = dat.list[[i]], n.beta = n.beta, v = v, 
                                       threshold = quantile(dat.train[dat.train$surface_downwelling_shortwave_flux_in_air > 0, "surface_downwelling_shortwave_flux_in_air"], 0.05), 
                                       resids = resids)
              } else {
                mod.out <- model.train(dat.subset = dat.list[[i]], n.beta = n.beta, v = v,
                  resids = resids)
              }
                
                
              # Save the betas as .nc
              outfile <- file.path(path.out, paste0("betas_", v, "_", i, ".nc"))
              dimY <- ncdf4::ncdim_def(paste0("coeffs_", i), units = "unitless", 
                                       longname = "model.out coefficients", vals = 1:ncol(mod.out[["betas"]]))
              dimX <- ncdf4::ncdim_def("random", units = "unitless", 
                                       longname = "random betas", vals = 1:nrow(mod.out[["betas"]]))
              var.list <- ncdf4::ncvar_def(paste(i), units = "coefficients", dim = list(dimX, dimY), 
                                           longname = paste0("day ", i, " model.out coefficients"))
              nc <- ncdf4::nc_create(outfile, var.list)
              ncdf4::ncvar_put(nc, var.list, mod.out[["betas"]])
              ncdf4::nc_close(nc)
              
              # Save the model as a .Rdata with only the info we need to recreate it 
              # (saves a lot of space & memory)
      				mod.save <- list()
      				mod.save$call  <- mod.out$model$call
      				mod.save$coef  <- coef(mod.out$model)
      				mod.save$formula <- parse(text=mod.out$model$call[[2]][c(1,3)])
      				mod.save$factors  <- rownames(attr(mod.out$model$terms, "factors"))
      				mod.save$xlev  <- mod.out$model$xlevels
      				mod.save$contr <- mod.out$model$contrasts
              save(mod.save, file = file.path(path.out, paste0("model_", v, "_", i, ".Rdata")))
                
              if(resids) {
      					# Save the betas as .nc
      					outfile <- file.path(path.out, paste0("resids_betas_", v, "_", i, ".nc"))
      					dimY <- ncdf4::ncdim_def(paste0("coeffs_", i), units = "unitless",
      					                         longname = "model.out coefficients", vals = 1:ncol(mod.out[["betas.resid"]]))
      					dimX <- ncdf4::ncdim_def("random", units = "unitless", 
      					                         longname = "random betas", vals = 1:nrow(mod.out[["betas.resid"]]))
      					var.list <- ncdf4::ncvar_def(i, units = "coefficients", dim = list(dimX, dimY), 
      					                             longname = paste0("day ", i, "resid model.out coefficients"))
      					nc <- ncdf4::nc_create(outfile, var.list)
      					ncdf4::ncvar_put(nc, var.list, mod.out[["betas.resid"]])
      					ncdf4::nc_close(nc)
      				
      					# Save the model as a .Rdata
      					mod.save <- list()
      					mod.save$call  <- mod.out$model.resid$call
      					mod.save$coef  <- coef(mod.out$model.resid)
      					mod.save$formula <- parse(text=mod.out$model.resid$call[[2]][c(1,3)])
      					mod.save$factors  <- rownames(attr(mod.out$model.resid$terms, "factors"))
      					mod.save$xlev  <- mod.out$model.resid$xlevels
      					mod.save$contr <- mod.out$model.resid$contrasts
      					save(mod.save, file = file.path(path.out, paste0("resids_model_", v, "_", i, ".Rdata")))
              } # End resids case

            } # End day loop
        } # End if else case

        if(print.progress==TRUE){
          pb.index <- pb.index + 1
          utils::setTxtProgressBar(pb, pb.index)
        }
    }  # end of the variable for loop
    
}  # end of the function





