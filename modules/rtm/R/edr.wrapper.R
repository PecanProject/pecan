#' @title ED radiative transfer module (EDR) wrapper function
#' 
#' @name EDR
#' @description This function provides a convenient way to call the ED 
#' radiative transfer module (EDR, which simulates full spectral return of an 
#' ED patch for a given point in time) directly from R.
#' @param paths List of relevant paths. Must contain the following:
#' `ed2in` -- Path to ED2IN file for the original ED run. If this is `NA`, the 
#' function assumes that the ED2IN file in `output.path` is already up-to-date 
#' and skips the analysis step.
#' `history` -- Path and prefix for history file for the run of interest;
#' `edr.exe` -- Path to EDR executable
#' `soil_reflect` -- Path to soil reflectance. If NULL or unset, use 
#' reflectance in package. If NA, skip (assume data already in directory).
#' `wood_reflect` -- Path to wood reflectance. If NULL or unset, use 
#' reflectance in package. If NA, skip (assume data already in directory).
#' @param spectra_list List of spectral data matrices. Names must exactly match 
#' the PFTs given in `trait.values`. Each item must be a matrix of wavelengths, 
#' reflectance, and transmittance values. Matrix must have column names 'wl' 
#' (wavelength), 'R' (reflectance), and 'T' (transmittance). Such a matrix is 
#' returned by default by all versions of PROSPECT in this package.
#' @param par.wl Vector of wavelengths defining PAR region
#' @param nir.wl Vector of wavelengths defining NIR region
#' @param datetime POSIXlt object defining the date and at which the run will 
#' take place. N datetime POSIXlt object defining the date and at which the run 
#' will take place. Note that runs at night and during the winter can give poor 
#' results.
#' @param trait.values Named, hierarchical list of trait values for generating 
#' config.xml file. Names must be PFTs, and must exactly match names of 
#' `spectra_list`.
#' @param settings PEcAn settings list. Default is model$revision = 'git', model$config.header = NULL.
#' @param history.prefix Prefix in histroy file name. Will be appended to 
#' history path.
#' @param edr.exe.name Name of EDR executable. Default = 'ed_2.1-opt'
#' @param change.history.time Logical. If `TRUE`, rename the history file to 
#' the time specified in `datetime`. Default = TRUE.
#' @param output.path Path to store all output files. Default is current 
#' working directory.
#' @param clean Logical. If `TRUE`, remove all files generated by this function 
#' (e.g. cloned history file, ED2IN, output HDF files).
#' 
#' @export
EDR <- function(paths,
                spectra_list,
                par.wl,
                nir.wl,
                datetime,
                trait.values,
                settings = list(model = list(revision = "git",
                                             config.header = NULL)),
                history.prefix = 'history',
                edr.exe.name = 'ed_2.1-opt',
                change.history.time = TRUE,
                output.path = getwd(),
                clean = FALSE) {

  # Extract paths
  # TODO: Provide option to just a results path with implied file structure
  # (ED2IN, config.xml, history)
  ed2in.path <- ifelse(is.na(paths$ed2in), NA, normalizePath(paths$ed2in))
  history.path <- normalizePath(paths$history)
  output.path <- normalizePath(output.path)
  
  # Process datetime
  if (!any(grepl("POSIX", class(datetime)))) {
    stop("datetime is not POSIX")
  }
  
  # Preprocess history file
  if (change.history.time) {
    history.full.prefix <- EDR.preprocess.history(history.path, output.path, datetime, history.prefix)
  } else {
    history.full.prefix <- file.path(history.path, history.prefix)
  }
  # TODO: Read old config file as template
  # This ensures that all PFTs and previous default trait values that were in the
  # run are loaded.
  # Pseudocode:
  # xml.old <- XML::xmlToList(XML::xmlParse(old.config.path))
  # defaults.old <- xml.old$defaults
  # settings.old <- xml.old$settings
  # trait.values.old <- xml.old$trait.values
  
  # Write ED2 config.xml file
  defaults <- list() 
  xml <- PEcAn.ED2::write.config.xml.ED2(defaults = defaults,
                                         settings = settings,
                                         trait.values = trait.values)
  
  new.config.path <- file.path(output.path, "config.xml")
  PREFIX_XML <- '<?xml version="1.0"?>\n<!DOCTYPE config SYSTEM "ed.dtd">\n'
  XML::saveXML(xml, file = new.config.path, indent=TRUE, prefix = PREFIX_XML)
  
  # Preprocess ED2IN Otherwise, skip this step
  if (!is.na(ed2in.path)) {
    EDR.preprocess.ed2in(ed2in.path, output.path, new.config.path, datetime, history.full.prefix)
  }
  
  # Generate input files
  files_list <- file.path(output.path, 
                          c('lengths.dat', 'reflect_par.dat', 'reflect_nir.dat',
                            'trans_par.dat', 'trans_nir.dat'))
  names(files_list) <- c('lengths', 'reflect_par', 'reflect_nir', 
                         'trans_par', 'trans_nir')
  file.create(files_list)

  write_dat <- function(value, file) {
    cat(value, file = file, sep = ' ', append = TRUE) 
    cat('\n', file = file, append = TRUE)
  }
  
  par.nir.lengths <- c(length(par.wl), length(nir.wl))
  write_dat(par.nir.lengths, files_list['lengths'])

  wavelengths <- spectra_list[[1]][,'wl']
  par.ind <- which(wavelengths %in% par.wl)
  nir.ind <- which(wavelengths %in% nir.wl)

  # Set up soil and wood reflectance files
  soil_reflect_path <- paths$soil_reflect
  if (is.null(soil_reflect_path)) {
    soil_reflect_path <- system.file('extdata', 'soil_reflect_par.dat', package = 'PEcAnRTM')
  }

  if (!is.na(soil_reflect_path)) {
    file.copy(soil_reflect_path, output.path, overwrite = TRUE, recursive = TRUE)
  }

  wood_reflect_path <- paths$wood_reflect
  if (is.null(wood_reflect_path)) {
    wood_reflect_path <- system.file('extdata', 'wood_reflect_par.dat', package = 'PEcAnRTM')
  }

  if (!is.na(wood_reflect_path)) {
    file.copy(wood_reflect_path, output.path, overwrite = TRUE, recursive = TRUE)
  }

  # Multi-PFT settings
  if (length(trait.values) > 0) {
    if (length(spectra_list) != length(trait.values)) {
      stop('Spectral data and trait.values do not have same length.\n',
           'Spectral data length: ', length(spectra_list), '\n',
           'trait.values length: ', length(trait.values))
    }
    pft_names <- names(trait.values)
    if (any(sort(names(spectra_list)) != sort(pft_names))) {
      stop('Spectral data and trait.values do not have same PFT names.\n',
           'Spectral data names: ', names(spectra_list), '\n',
           'trait.values names: ', pft_names)
    }
    data(pftmapping, package = 'PEcAn.ED2')
    npft <- length(pft_names)
    write_dat(npft, files_list['lengths'])
    pft_numbers <- numeric(npft)
    for (i in seq_len(npft)) {
      pft_numbers[i] <- pftmapping[pftmapping$PEcAn == pft_names[i], 'ED']
      write_dat(pft_numbers[i], files_list['lengths'])
      spectra_list_pft <- spectra_list[[pft_names[i]]]
      write_dat(spectra_list_pft[par.ind, 'R'], files_list['reflect_par'])
      write_dat(spectra_list_pft[nir.ind, 'R'], files_list['reflect_nir'])
      write_dat(spectra_list_pft[par.ind, 'T'], files_list['trans_par'])
      write_dat(spectra_list_pft[nir.ind, 'T'], files_list['trans_nir'])
    }
  }
  
  # Call EDR -- NOTE that this requires that the ED2IN
  exec.command <- sprintf("(cd %s; ./%s)", output.path, edr.exe.name)
  ex <- system(exec.command, intern = TRUE)
  if (any(grepl("fatal error", ex, ignore.case = TRUE))) {
    print(ex)
    stop("Error executing EDR")
  }
  # Analyze output
  albedo <- get.EDR.output(output.path)
  # Optionally, clean up all generated files
  if(clean) {
    delete.files <- file.remove(files_list)
    # NOTE that currently, not all files are deleted (e.g. history file, copied ED2IN)
    if (!delete.files) {
      warning("Error in deleting files.")
    }
  }
  return(albedo)
} # EDR


#' @title ED RTM coupled to PROSPECT leaf RTM
#' 
#' @name EDR.prospect
#' @param prospect.param Vector of PROSPECT parameters
#' @param prospect.version Version of PROSPECT to use. Default = 5
#' @param paths List of paths required by EDR
#' @param par.wl Vector of wavelengths constituting PAR.
#' @param nir.wl Vector of wavelengtsh constituting NIR.
#' @param datetime POSIX datetime object for EDR run
#' @param ... Other arguments to EDR
#' @examples
#' \dontrun{
#'   ed2in.path <- '/projectnb/dietzelab/pecan.data/output/ashiklom/1000001295/run/1000336885/ED2IN' # Note that the file itself is pointed to
#'   history.path <- '/projectnb/dietzelab/pecan.data/output/ashiklom/1000001295/out/1000336885/'    # Note that the prefix is NOT included -- only the directory path
#'   paths <- list(ed2in.path = ed2in.path, history.path = history.path)
#'   par.wl <- 400:750
#'   nir.wl <- 751:2500
#'   prospect.param <- c(1.4, 40, 5, 0.01, 0.01)
#'   prospect.version <- 5
#'   datetime <- ISOdatetime(2004, 07, 01, 12, 00, 00)
#'   albedo <- EDR.prospect(prospect.param = prospect.param,
#'                          prospect.version = prospect.version,
#'                          paths=paths, 
#'                          par.wl = par.wl, nir.wl = nir.wl,
#'                          datetime = datetime, 
#'                          history.prefix = 'history', change.history.time = TRUE,
#'                          output.path = getwd())
#'   plot(albedo, type='l')
#' }
#' @export
EDR.prospect <- function(prospect.param, prospect.version = 5, paths, par.wl, nir.wl, datetime, ...) {
  stop('This function is currently deprecated. Use `EDR(...)` instead.')
  RT.matrix <- prospect(prospect.param, prospect.version, include.wl = TRUE)
  albedo <- EDR(paths, RT.matrix, par.wl, nir.wl, datetime, ...)
  return(albedo)
}  # EDR.prospect

#' @title Read EDR output
#' 
#' @name get.EDR.output
#' @param path Path to directory containing `albedo_par/nir.dat` files
#' @export
get.EDR.output <- function(path = getwd()) {
  alb.par <- as.matrix(read.table(file.path(path, "albedo_par.dat")))[1, ]
  alb.nir <- as.matrix(read.table(file.path(path, "albedo_nir.dat")))[1, ]
  albedo <- c(alb.par, alb.nir)
  return(albedo)
}

#' @title Preprocess history file for EDR
#' 
#' @name EDR.preprocess.history
#' @description Locate history file based on path and prefix, copy to specified 
#' output directory, and rename to correct time.
#' @param history.path Path to directory containing history file.
#' @param history.prefix String describing the history file prefix in 
#' `history.path`. Default = 'history'
#' @param datetime POSIX date and time for run
#' @export
EDR.preprocess.history <- function(history.path, output.path, datetime, history.prefix = "history") {
  # Check inputs
  stopifnot(is.character(history.path))
  stopifnot(is.character(history.prefix))
  if (!any(grepl("POSIX", class(datetime)))) {
    stop("datetime is not POSIX")
  }
  # Extract date and time
  day          <- strftime(datetime, "%d")
  month        <- strftime(datetime, "%m")
  year         <- strftime(datetime, "%Y")
  time.history <- strftime(datetime, "%H%M%S")
  # Locate history file
  history.search <- sprintf("%1$s-S-%2$s-%3$s-%4$s",
                            history.prefix, year, month, day)
  history.name <- list.files(history.path, history.search)
  history.full.path <- file.path(history.path, history.name)
  if (length(history.name) > 1) {
    stop("Multiple history files matched")
  }
  if (length(history.name) == 0) {
    stop("No history files found")
  }
  # Copy and rename history file
  history.new.name <- gsub('([[:digit:]]{6})', time.history, history.name)
  history.new.path <- file.path(output.path, history.new.name)
  history.copy <- file.copy(history.full.path, history.new.path, overwrite = FALSE)
  if (!history.copy) {
    warning("Could not copy history with overwrite=FALSE. Attempting with overwrite=TRUE")
    history.copy <- file.copy(history.full.path, history.new.path, overwrite = TRUE)
    if (!history.copy) {
      stop("Unable to copy history file, even with overwrite=TRUE. Check permissions on both input and output directories.")
    }
  }
  history.full.prefix <- file.path(output.path, history.prefix)
  return(history.full.prefix)
} # EDR.preprocess.history


#' @title Preprocess ED2IN file for EDR
#' 
#' @name EDR.preprocess.ed2in
#' @description Copy ED2IN to `output.path` and modify for EDR specifications
#' @param ed2in.path Path to original ED2IN file.
#' @param output.path Path to directory for new ED2IN file (and where analysis 
#' is performed)
#' @param datetime POSIX datetime object defining the time at which to run EDR
#' @param history.full.prefix Full path and prefix for history file
#' @export
EDR.preprocess.ed2in <- function (ed2in.path, output.path, config.path, datetime, 
                                  history.full.prefix) {
  # Process datetime
  day        <- strftime(datetime, "%d")
  month      <- strftime(datetime, "%m")
  year       <- strftime(datetime, "%Y")
  starttime  <- "0000"  # Not the RTM time, but the 'model' time (shouldn't matter)
  nextdate   <- as.Date(datetime) + 1  # For 'terminating' the run -- set to next day (shouldn't matter)
  nextday    <- strftime(nextdate, "%d")
  nextmonth  <- strftime(nextdate, "%m")
  nextyear   <- strftime(nextdate, "%Y")
  nexttime   <- "0000"  # Not the RTM time, but the 'model' time -- shouldn't matter
  time.ed2in <- strftime(datetime, "%H%M")
  # Copy ED2IN to output.path
  ed2in.copy <- file.copy(ed2in.path, output.path) # Copy ED2IN to local directory -- returns logical
  if(!ed2in.copy) {
    warning("Could not copy ED2IN with overwrite=FALSE. Attempting with overwrite=TRUE")
    ed2in.copy <- file.copy(ed2in.path, output.path, overwrite=TRUE)
    if(!ed2in.copy) {
      stop('Unable to copy ED2IN file, even with overwrite=TRUE. Check permissions on both input and output directories.')
    }
  }
  # Modify ED2IN
  ed2in.local.path <- file.path(output.path, "ED2IN")
  ed2in <- readLines(ed2in.local.path)
  ed2in <- gsub("(NL%RUNTYPE).*", 
                sprintf("\\1 = '%s'  !! MODIFIED BY R WRAPPER", "HISTORY"), 
                ed2in)
  # Start day and time
  ed2in <- gsub("(NL%IMONTHA).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", month), 
                ed2in)
  ed2in <- gsub("(NL%IDATEA).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", day), 
                ed2in)
  ed2in <- gsub("(NL%IYEARA).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", year),
                ed2in)
  ed2in <- gsub("(NL%ITIMEA).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", starttime), 
                ed2in)
  # End date and time
  ed2in <- gsub("(NL%IMONTHZ).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", nextmonth), 
                ed2in)
  ed2in <- gsub("(NL%IDATEZ).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", nextday), 
                ed2in)
  ed2in <- gsub("(NL%IYEARZ).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", nextyear),
                ed2in)
  ed2in <- gsub("(NL%ITIMEZ).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", nexttime),
                ed2in)
  # Output file location
  ed2in <- gsub("(NL%FFILOUT).*", 
                sprintf("\\1 = '%s/analysis'  !! MODIFIED BY R WRAPPER", output.path), 
                ed2in)
  ed2in <- gsub("(NL%SFILOUT).*",
                sprintf("\\1 = '%s/history'  !! MODIFIED BY R WRAPPER", output.path),
                ed2in)
  # Input (history) file location
  ed2in <- gsub("(NL%SFILIN).*", 
                sprintf("\\1 = '%s'  !! MODIFIED BY R WRAPPER", history.full.prefix),
                ed2in)
  # History file information
  ed2in <- gsub("(NL%ITIMEH).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", time.ed2in), 
                ed2in)
  ed2in <- gsub("(NL%IDATEH).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", day), 
                ed2in)
  ed2in <- gsub("(NL%IMONTHH).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", month), 
                ed2in)
  ed2in <- gsub("(NL%IYEARH).*", 
                sprintf("\\1 = %s  !! MODIFIED BY R WRAPPER", year),
                ed2in)
  # config.xml file
  ed2in <- gsub("(NL%IEDCNFGF).*", 
                sprintf("\\1 = '%s'  !! MODIFIED BY R WRAPPER", config.path), 
                ed2in)
  # Write resulting ED2IN to file
  write(ed2in, file = ed2in.local.path)
} # EDR.preprocess.ed2in
