# @name EDR
#' @title ED radiative transfer module (EDR) wrapper function
#' @description This function provides a convenient way to call the ED 
#' radiative transfer module (EDR, which simulates full spectral return of an 
#' ED patch for a given point in time) directly from R.
#' @param paths List of relevant paths. Must contain the following:
#' `ed2in` -- Path to ED2IN file for the original ED run. If this is `NA`, the 
#' function assumes that the ED2IN file in `output.path` is already up-to-date 
#' and skips the analysis step.
#' `history` -- Path and prefix for history file for the run of interest;
#' `edr.exe` -- Path to EDR executable
#' @param RT.matrix Matrix of wavelengths, reflectance, and transmittance 
#' values. Matrix must have column names "wl" (wavelength), "R" (reflectance), 
#' and "T" (transmittance). Such a matrix is returned by default by all 
#' versions of PROSPECT in this package.
#' @param par.wl Vector of wavelengths defining PAR region
#' @param nir.wl Vector of wavelengths defining NIR region
#' @param datetime POSIXlt object defining the date and at which the run will 
#' take place. N datetime POSIXlt object defining the date and at which the run 
#' will take place. Note that runs at night and during the winter can give poor 
#' results.
#' @param history.prefix Prefix in histroy file name. Will be appended to 
#' history path.
#' @param edr.exe.name Name of EDR executable. Default = 'ed_2.1-opt'
#' @param change.history.time Logical. If `TRUE`, rename the history file to 
#' the time specified in `datetime`. Default = TRUE.
#' @param output.path Path to store all output files. Default is current 
#' working directory.
#' @param clean Logical. If `TRUE`, remove all files generated by this function 
#' (e.g. cloned history file, ED2IN, output HDF files).

EDR <- function(paths,
                RT.matrix,
                par.wl,
                nir.wl,
                datetime,
                history.prefix = 'history',
                edr.exe.name = 'ed_2.1-opt',
                change.history.time = TRUE,
                output.path = getwd(),
                clean = FALSE){

# Extract paths
    ed2in.path <- paths$ed2in
    history.path <- paths$history

# Process datetime
    if(!any(grepl("POSIX", class(datetime)))) stop("datetime is not POSIX")

# Preprocess history file
    if(change.history.time){
        history.full.prefix <- EDR.preprocess.history(history.path, output.path, datetime, history.prefix)
    } else {
        history.full.prefix <- file.path(history.path, history.prefix)
    }

# Preprocess ED2IN
    if(!is.na(ed2in.path)){     # Otherwise, skip this step
        EDR.preprocess.ed2in(ed2in.path, output.path, datetime, history.full.prefix)
    }

# Generate input files
    par.nir.lengths <- c(length(par.wl), length(nir.wl))
    cat(par.nir.lengths, file=file.path(output.path, "lengths.dat"), sep = ' ')
    par.ind <- which(RT.matrix[,"wl"] %in% par.wl)    # PAR indices -- offset by 399
    nir.ind <- which(RT.matrix[,"wl"] %in% nir.wl)    # NIR indices 
    cat(RT.matrix[par.ind,1], file = file.path(output.path, "reflect_par.dat"), sep=" ")
    cat(RT.matrix[nir.ind,1], file = file.path(output.path, "reflect_nir.dat"), sep=" ")
    cat(RT.matrix[par.ind,2], file = file.path(output.path, "trans_par.dat"), sep=" ")
    cat(RT.matrix[nir.ind,2], file = file.path(output.path, "trans_nir.dat"), sep=" ")
# Call EDR -- NOTE that this requires that the ED2IN 
    system(file.path(output.path, edr.exe.name), intern=TRUE)
# Analyze output
    albedo <- get.EDR.output(output.path)
# Optionally, clean up all generated files
    if(clean){
        delete.files <- file.remove(file.path(output.path,
                                              c('lengths.dat',
                                                'reflect_par.dat',
                                                'reflect_nir.dat',
                                                'trans_par.dat',
                                                'trans_nir.dat')))
# NOTE that currently, not all files are deleted (e.g. history file, copied ED2IN)
        if(!delete.files) warning('Error in deleting files.')
    }
    return(albedo)
}

#' @name get.EDR.output
#' @title Read EDR output
#' @param path Path to directory containing `albedo_par/nir.dat` files
get.EDR.output <- function(path=getwd()){
    nir.table <- read.table(file.path(path, "albedo_nir.dat"))
    par.table <- read.table(file.path(path, "albedo_par.dat"))
    alb.nir <- unlist(nir.table[1,])
    alb.par <- unlist(par.table[1,])
    albedo <- c(alb.par, alb.nir)
    return(albedo)
}

#' @name EDR.preprocess.history
#' @title Preprocess history file for EDR
#' @description Locate history file based on path and prefix, copy to specified 
#' output directory, and rename to correct time.
#' @param history.path Path to directory containing history file.
#' @param history.prefix String describing the history file prefix in 
#' `history.path`. Default = 'history'
#' @param datetime POSIX date and time for run
EDR.preprocess.history <- function(history.path, output.path, datetime, history.prefix='history'){
# Check inputs
    stopifnot(is.character(history.path))
    stopifnot(is.character(history.prefix))
    if(!any(grepl("POSIX", class(datetime)))) stop("datetime is not POSIX")
# Extract date and time
    day <- strftime(datetime, "%d")
    month <- strftime(datetime, "%m")
    year <- strftime(datetime, "%Y")
    time.history <- strftime(datetime, "%H%M%S")
# Locate history file
    history.search <- sprintf("%1$s-S-%2$s-%3$s-%4$s",
                              history.prefix,
                              year, month, day)
    history.name <- list.files(history.path, history.search)
    history.full.path <- file.path(history.path, history.name)
    if(length(history.name) > 1) stop("Multiple history files matched")
    if(length(history.name) == 0) stop("No history files found")
# Copy and rename history file
    history.new.name <- gsub('([[:digit:]]{6})', time.history, history.name)
    history.new.path <- file.path(output.path, history.new.name)
    history.copy <- file.copy(history.full.path, history.new.path, overwrite=FALSE)
    if(!history.copy){
        warning("Could not copy history with overwrite=FALSE. Attempting with overwrite=TRUE")
        history.copy <- file.copy(history.full.path, history.new.path, overwrite=TRUE)
        if(!history.copy) stop('Unable to copy history file, even with overwrite=TRUE. Check permissions on both input and output directories.')
    }
    history.full.prefix <- file.path(output.path, history.prefix)
    return(history.full.prefix)
}

#' @name EDR.preprocess.ed2in
#' @title Preprocess ED2IN file for EDR
#' @description Copy ED2IN to `output.path` and modify for EDR specifications
#' @param ed2in.path Path to original ED2IN file.
#' @param output.path Path to directory for new ED2IN file (and where analysis 
#' is performed)
#' @param datetime POSIX datetime object defining the time at which to run EDR
#' @param history.full.prefix Full path and prefix for history file
EDR.preprocess.ed2in <- function(ed2in.path, output.path, datetime, history.full.prefix){
# Process datetime
    day <- strftime(datetime, "%d")
    month <- strftime(datetime, "%m")
    year <- strftime(datetime, "%Y")
    starttime <- '0000'     # Not the RTM time, but the "model" time (shouldn't matter)
    nextdate <- as.Date(datetime) + 1   # For 'terminating' the run -- set to next day (shouldn't matter)
    nextday <- strftime(nextdate, "%d")
    nextmonth <- strftime(nextdate, "%m")
    nextyear <- strftime(nextdate, "%Y")
    nexttime <- '0000'      # Not the RTM time, but the "model" time -- shouldn't matter
    time.ed2in <- strftime(datetime, "%H%M")
# Copy ED2IN to output.path
    ed2in.copy <- file.copy(ed2in.path, output.path) # Copy ED2IN to local directory -- returns logical
    if(!ed2in.copy) stop('Error copying ED2IN')
    # Modify ED2IN
    ed2in.local.path <- file.path(output.path, "ED2IN")
    ed2in <- readLines(ed2in.local.path)
    ed2in <- gsub('(NL%RUNTYPE).*', 
                  sprintf("\\1 = '%s'  !! MODIFIED BY R WRAPPER", 'HISTORY'), ed2in)
    # Start day and time
    ed2in <- gsub('(NL%IMONTHA).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', month), ed2in)
    ed2in <- gsub('(NL%IDATEA).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', day), ed2in)
    ed2in <- gsub('(NL%IYEARA).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', year), ed2in)
    ed2in <- gsub('(NL%ITIMEA).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', starttime), ed2in)
    # End date and time
    ed2in <- gsub('(NL%IMONTHZ).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', nextmonth), ed2in)
    ed2in <- gsub('(NL%IDATEZ).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', nextday), ed2in)
    ed2in <- gsub('(NL%IYEARZ).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', nextyear), ed2in)
    ed2in <- gsub('(NL%ITIMEZ).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', nexttime), ed2in)
    # Output file location
    ed2in <- gsub('(NL%FFILOUT).*', 
                  sprintf("\\1 = '%s/analysis'  !! MODIFIED BY R WRAPPER", output.path), ed2in)
    ed2in <- gsub('(NL%SFILOUT).*', 
                  sprintf("\\1 = '%s/history'  !! MODIFIED BY R WRAPPER", output.path), ed2in)
    # Input (history) file location
    ed2in <- gsub('(NL%SFILIN).*', 
                  sprintf("\\1 = '%s'  !! MODIFIED BY R WRAPPER", history.full.prefix), ed2in)
    # History file information
    ed2in <- gsub('(NL%ITIMEH).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', time.ed2in), ed2in)
    ed2in <- gsub('(NL%IDATEH).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', day), ed2in)
    ed2in <- gsub('(NL%IMONTHH).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', month), ed2in)
    ed2in <- gsub('(NL%IYEARH).*', 
                  sprintf('\\1 = %s  !! MODIFIED BY R WRAPPER', year), ed2in)
    # Write resulting ED2IN to file
    write(ed2in, file = ed2in.local.path)
}
