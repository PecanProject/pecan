#' metSplit
#'
#' @param conf.settings listed multisite settings object generated by sda.enkf_MultiSite
#' @param inputs listed object containing met ensemble members generated by input.ens.gen
#' @param settings settings object passed to sda.enkf_MultiSite
#' @param model model name ex. SIPNET
#' @param no_split TRUE/FALSE if model requires met split
#' @param obs.times matrix of dates used for assimilation
#' @param t number of dates in obs.times
#' @param nens number of ensemble members, taken from settings object
#' @param restart_flag TRUE/FALSE taken from restart arguement
#' @param my.split_inputs generated by sda.enkf_MultiSite ex. split_inputs.SIPNET
#' @export
#'
#' @return input.split object with split met filepaths
#' 
#' @author Alexis Helgeson
#'
metSplit <- function(conf.settings, inputs, settings, model, no_split = FALSE, obs.times, t, nens, restart_flag = FALSE, my.split_inputs){
  
  #set start and end date for splitting met
  start.time = obs.times[t - 1] #always start timestep before
  
  if(restart_flag){
    stop.time = settings$run$site$met.end
  }else{
    stop.time = obs.times[t]
  }
  #-Splitting the input for the models that they don't care about the start and end time of simulations and they run as long as their met file.
  inputs.split <- conf.settings %>%
    `class<-`(c("list")) %>%
    purrr::map2(inputs, function(settings, inputs) {
      # Loading the model package - this is required bc of the furrr
      library(paste0("PEcAn.",model), character.only = TRUE)
      
      inputs.split <- list()
      if (!no_split) {
        for (i in seq_len(nens)) {
          #---------------- model specific split inputs
          inputs.split$samples[i] <- do.call(
            my.split_inputs,
            args = list(
              settings = settings,
              start.time = (lubridate::ymd_hms(start.time, truncated = 3) + lubridate::second(lubridate::hms("00:00:01"))),
              stop.time =   lubridate::ymd_hms(stop.time, truncated = 3),
              inputs = inputs$samples[[i]])
          )
        }
      } else{
        inputs.split <- inputs
      }
      inputs.split
    })
  
  return(inputs.split)
}
