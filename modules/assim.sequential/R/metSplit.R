#' metSplit
#'
#' @param conf.settings listed multisite settings object generated by sda.enkf_MultiSite
#' @param inputs listed object containing met ensemble members generated by input.ens.gen
#' @param settings settings object passed to sda.enkf_MultiSite
#' @param model model name ex. SIPNET
#' @param no_split TRUE/FALSE if model requires met split
#' @param obs.times matrix of dates used for assimilation
#' @param t number of dates in obs.times
#' @param nens number of ensemble members, taken from settings object
#' @param restart_flag TRUE/FALSE taken from restart arguement
#' @param my.split_inputs generated by sda.enkf_MultiSite ex. split_inputs.SIPNET
#' @param outpath if specified, write output to a new directory. Default NULL writes back to the directory being read
#' @export
#'
#' @return input.split object with split met filepaths
#' 
#' @author Alexis Helgeson
#'
metSplit <- function(conf.settings, inputs, settings, model, no_split = FALSE, obs.times, t, nens, restart_flag = FALSE, my.split_inputs, outpath=NULL){
  
  #set start and end date for splitting met
  start.time = obs.times[t - 1] #always start timestep before
  
  if(restart_flag){
    stop.time = settings$run$site$met.end
  }else{
    stop.time = obs.times[t]
  }
  
  inputs.orig = inputs
  nens.orig   = nens
  if(!is.null(outpath)){
    ## build a temporary inputs object based on original inputs in settings
    for(i in seq_along(inputs)){
      inputs[[i]]$samples = settings[[i]]$run$inputs$met$path
    }
    nens = length(settings[[i]]$run$inputs$met$path)
  }
  
  #-Splitting the input for the models that they don't care about the start and end time of simulations and they run as long as their met file.
  inputs.split <- 
    furrr::future_pmap(list(conf.settings %>% `class<-`(c("list")), inputs, model), function(settings, inputs, model) {
      # Loading the model package - this is required bc of the furrr
      library(paste0("PEcAn.",model), character.only = TRUE)
      
      inputs.split <- list()
      if (!no_split) {
        for (i in seq_len(nens)) {
          #---------------- model specific split inputs
          inputs.split$samples[i] <- do.call(
            my.split_inputs,
            args = list(
              settings = settings,
              start.time = (lubridate::ymd_hms(start.time, truncated = 3) + lubridate::second(lubridate::hms("00:00:01"))),
              stop.time =   lubridate::ymd_hms(stop.time, truncated = 3),
              inputs = inputs$samples[[i]],
              outpath = file.path(outpath,settings$run$site$id)
            )
          )
        }
      } else{
        inputs.split <- inputs
      }
      inputs.split
    })
    
  ## match split original files back to resampled
  if(!is.null(outpath)){
    
    new.inputs = inputs.orig
    for(i in seq_along(inputs)){
      new.inputs[[i]] = list()
      parent.input = settings[[i]]$run$inputs$met$path ## set of parent met
      for(e in seq_along(inputs.orig[[i]]$samples)){
        ## extract prefix from old split ensemble member
        old = sub(".clim","",basename(inputs.orig[[i]]$samples[[e]]),fixed=TRUE)
        old = strsplit(old,split=".",fixed=TRUE)[[1]][1]
        ## match ensemble member
        ens = grep(old,unlist(parent.input)) 
        ## swap
        new.inputs[[i]]$samples[[e]] = inputs.split[[i]]$samples[[ens]]
      }
      names(new.inputs[[i]]$samples) = rep("path",nens.orig)
    }
    
    inputs.split = new.inputs
    
 } ### end match

  return(inputs.split)
}
