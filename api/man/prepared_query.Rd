% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prepared_query.R
\name{prepared_query}
\alias{prepared_query}
\alias{prepared_statement}
\title{Execute a PostgreSQL prepared query or statement}
\usage{
prepared_query(con, query, params)

prepared_statement(con, query, params)
}
\arguments{
\item{con}{Database connection, as created by \link[RPostgres:dbConnect]{RPostgres::dbConnect}}

\item{query}{Query template (character, length 1)}

\item{params}{Query parameters (unnamed list)}
}
\value{
For \code{prepared_query}, the query result as a \code{data.frame}.
\code{prepared_statement} exits silently on success.
}
\description{
This provides a safe and efficient way of executing a query or
statement with a list of parameters to be substituted.
}
\details{
A prepared statement consists of a template query (\code{query}), which
is compiled prior to execution, and a series of parameters
(\code{params}) that are passed into the relevant spots in the template
query. In R's \code{DBI} database interface, this uses three statements:
\link[DBI:dbSendQuery]{DBI::dbSendQuery} to create the template query, \link[DBI:dbBind]{DBI::dbBind} to
bind parameters to that query, and \link[DBI:dbFetch]{DBI::dbFetch} to retrieve the
results. Statements (\link[DBI:dbSendStatement]{DBI::dbSendStatement}) work the same way,
except there are no results to fetch with \link[DBI:dbFetch]{DBI::dbFetch}.

Prepared statements have several important advantages. First of
all, they are automatically and efficiently vectorized, meaning
that it is possible to build a single query and run it against a
vector of parameters. Second, they automatically enforce strict
type checking and quoting of inputs, meaning that they are secure
against SQL injection attacks and input mistakes (e.g. giving a
character when the table expects a number).
}
\examples{
\dontrun{
prepared_query(con, paste(
  "SELECT id, folder FROM workflows",
  "WHERE user_id = $1"
), list(my_user_id))

prepared_statement(con, paste(
  "INSERT INTO workflows (id, site_id, model_id, folder)",
  "VALUES ($1, $2, $3, $4)"
), list(workflow_id, my_site_id, my_model_id, my_folder))

# Note that queries and statements are automatically vectorized
# The below query will execute two searches, and return the results
# of both in one data.frame
prepared_query(con, paste(
  "SELECT * FROM dbfiles",
  "WHERE file_name ILIKE $1",
), list(c("\%cruncep\%", "\%gfdl\%")))

# Similarly, this will create two workflows, all with the same
  model_id (1) but different site_ids (33, 67)
prepared_statement(con, paste(
  "INSERT INTO workflows (site_id, model_id)",
  "VALUES ($1, $2)"
), list(c(33, 67), 1))

}
}
\author{
Alexey Shiklomanov
}
