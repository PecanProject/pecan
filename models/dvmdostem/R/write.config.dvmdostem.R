
##' Setup the output variables that dvmdostem will generate and PEcAn will analyze.
##' This function handles the interplay between output variables and output spec file.
##' There are custom tags in the <model> section of the pecan xml file for dvmdostem
##' that allow the user to specifiy a list of variables to generate and process,
##' and a custom path to an output spec file. The need for a custom path to an output
##' spec file is mostly gone with the addition of the variable list, but will be left
##' in place in case there is a future need for it. This function looks at the client
##' supplied settings for output spec path and variable list and returns the path
##' to the final run specific output spec file and the list of variables to
##' process. The run specific output spec file is copied into place and adjusted
##' using the dvmdostem script for working with output spec files. 
##'
##' @name setup.outputs.dvmdostem
##' @title Setup outputs to be generated by dvmdostem and analyzed by PEcAn.
##' @param dvmdostem_calibration a string with 'yes' or 'YES'
##' @param pecan_requested_outputs a space separated string of variables to process or NULL.
##' @param dvmdostem_output_spec a path to a custom output spec file or NULL.
##' @param run_directory a path to the direcotory containing the PEcAn run.
##' @param run_id the identifier for this individual run (usually a 10 digit number).
##' @param appbinary_path path to the dvmdostem application.
##' @return Vector containing path to the run specific output spec file and the final
##'   space separated string of out variables to pecanify.
##' @export
##' @author Tobey Carman
##'
setup.outputs.dvmdostem <- function(dvmdostem_calibration,
                                    pecan_requested_outputs, 
                                    dvmdostem_output_spec, 
                                    run_directory,
                                    run_id,
                                    appbinary_path) {
  
  is.not.null <- function(x) !is.null(x) # helper for readability

  # 0) neither path or variables specified
  if (is.null(pecan_requested_outputs) && is.null(dvmdostem_output_spec)) {
    PEcAn.logger::logger.error("You MUST specify either out variable list or custom output spec path.")
    stop()
  }
  # 1) user specifes outvars, no custom path
  if (is.not.null(pecan_requested_outputs) && is.null(dvmdostem_output_spec)) {
    outspec_path <- file.path(system.file(package = "PEcAn.dvmdostem"), "output_spec.csv")
    pecan_outvars <- pecan_requested_outputs
  }
  # 2) user specified custom path, no outvars
  if (is.not.null(dvmdostem_output_spec) && is.null(pecan_requested_outputs)) {
    PEcAn.logger::logger.warn("You probably want to specify output variables as well via the <dvmdostem_pecan_outputs> tag.")
    pecan_outvars <- "GPP NPP SoilOrgC VegC LAI"
    outspec_path <- dvmdostem_output_spec
    if (dirname(outspec_path) == ".") {
      # User specified the name of another file that should be in the inst folder
      outspec_path <- file.path(system.file(package = "PEcAn.dvmdostem"), outspec_path)
    } else {
      # nothing to do - user must have specified absolute path
    }
  }
  # 3) user specified both custom output spec and variable list
  if (is.not.null(pecan_requested_outputs) && is.not.null(dvmdostem_output_spec)) {
    pecan_outvars <- pecan_requested_outputs
    outspec_path <- dvmdostem_output_spec
  }
  
  # Calibraton run? 
  if (grepl(tolower(dvmdostem_calibration), 'yes', fixed = TRUE )) {
    PEcAn.logger::logger.warn("Calibration run requested! Ignoring requested ",
                              "output variables and using pre-set dvmdostem ",
                              "calibration outputs list")

    # Copy the base file to a run-specific output spec file
    if (! file.exists(file.path(run_directory, "config")) ) {
      dir.create(file.path(run_directory, "config"), recursive = TRUE)
    }
    rs_outspec_path <- file.path(run_directory, "config/", basename(outspec_path))
    file.copy(outspec_path, rs_outspec_path)
    
    # Empty the run specific output spec file
    system2(file.path(appbinary_path, "scripts/outspec_utils.py"), 
            args=c("--empty", rs_outspec_path))
    
    # Turn on the dvmdostem calibration outputs
    system2(file.path(appbinary_path, "scripts/outspec_utils.py"),
            args=c(rs_outspec_path, "--enable-cal-vars"))

    # Now enable anything in pecan_outvars that is not already enabled.
    requested_vars <- requested_vars_string2list(pecan_outvars, outspec_path = rs_outspec_path)
    
    # Figure out which variables are already 'ON' in order to support the calibration
    # run. These will be at yearly resolution. We don't want to modify the output spec 
    # setting for any of the calibration variables, not to mention the redundant work
    # (extra system call) to turn the variable on again.
    a <- system2(file.path(appbinary_path, "scripts/outspec_utils.py"), 
                 args=c(rs_outspec_path, "-s", "--csv"), stdout=TRUE)
    con <- textConnection(a)
    already_on <- utils::read.csv(con, header = TRUE)

    for (j in req_v_list) {
      if (j %in% already_on$Name) {
        PEcAn.logger::logger.info(paste0("Passing on ",j,"; it is already enabled..." ))
      } else {
        system2(file.path(appbinary_path, "scripts/outspec_utils.py"),
                args=c(rs_outspec_path, "--on", j, "y", "m"))
      }
    }

    ret <- system2(file.path(appbinary_path, "scripts/outspec_utils.py"), 
                   args=c(rs_outspec_path, "--summary"), 
                   stdout=TRUE, stderr=TRUE)

    req_v_str <- paste0(sapply(strsplit(ret, "\\s+"), function(a) a[2])[-1], collapse = " ")
    
        
  # done with calibration setup
  } else { 
    # not a calibration run
    # Verify that the base output_spec file exists.
    if (! file.exists(outspec_path) ) {
      PEcAn.logger::logger.error("ERROR! The specified output spec file does not exist on this system!")
      PEcAn.logger::logger.error(c("Cannot find file: ", outspec_path))
      stop()
    }
    
    # Check that at least one variable is enabled.
    if( length(unlist((strsplit(pecan_outvars, ",")))) < 1 ){ 
      PEcAn.logger::logger.error("ERROR! No output variables enabled!")
      PEcAn.logger::logger.error("Try adding the <dvmdostem_pecan_outputs> tag to your pecan.xml file!")
      stop()
    }
    
    req_var_list <- requested_vars_string2list()
    
    # Copy the base file to a run-specific output spec file
    if (! file.exists(file.path(run_directory, "config")) ) {
      dir.create(file.path(run_directory, "config"), recursive = TRUE)
    }
    rs_outspec_path <- file.path(run_directory, "config/", basename(outspec_path))
    file.copy(outspec_path, rs_outspec_path)
    
    # A more sophisticated test will verify that all the variables 
    # are valid at the correct dimensions(month and year??)
    
    # Empty the run specific output spec file
    system2(file.path(appbinary_path, "scripts/outspec_utils.py"), 
            args=c("--empty", rs_outspec_path))
    
    # Fill the run specific output spec file according to list
    for (j in req_v_list) {
      system2(file.path(appbinary_path, "scripts/outspec_utils.py"),
              args=c(rs_outspec_path, "--on", j, "y", "m"))
    }
  } # Done with non-calibration run setup

  # Print summary for debugging
  #system2(file.path(appbinary_path, "scripts/outspec_utils.py"), 
  #        args=c("-s", rs_outspec_path))
  
  return(c(rs_outspec_path, req_v_str))
}

##------------------------------------------------------------------------------------------------#
##' Look up the "depends_on" in the output variable mapping, 
##' accumulate a list of dvmdostem variables to turn on to support 
##' the requested variables in the pecan.xml tag
##'
##' @name requested_vars_string2list
##' @title Requested variables string to list conversion.
##' @param req_v_str A string, (comma or space separated?) of variables
##' @param outspec_path The path to an outspec file
##' @return a list of the requested variables
##' @export
##' @author Tobey Carman
requested_vars_string2list <- function(req_v_str, outspec_path) {
  req_v_str <- ""
  for (pov in unlist(lapply(unlist(strsplit(pecan_outvars, ",")), trimws))) {
    #print(paste("HERE>>>", vmap_reverse[[pov]][["depends_on"]]))
    req_v_str <- trimws(paste(req_v_str, vmap_reverse[[pov]][["depends_on"]], sep = ","))
  }
  # # Ugly, but basically jsut takes care of stripping out empty strings and 
  # making sure the final result is a 1D list, not nested.
  req_v_str <- trimws(req_v_str)
  req_v_list <- unlist(lapply(unlist(strsplit(req_v_str, ",")), function(x){x[!x== ""]}))

  # Check that all variables specified in list exist in the base output spec file.
  a <- utils::read.csv(rs_outspec_path)
  for (j in req_v_list) {
    if (! j %in% a[["Name"]]) {
      PEcAn.logger::logger.error(paste0("ERROR! Can't find variable: '", j, "' in the output spec file: ", rs_outspec_path))
      stop()
    }
  }

  return(req_v_list)
}






#' Convert samples for dvmdostem
#'
#' convert parameters, do unit conversions and update parameter names from PEcAn database default
#' to units/names within dvmdostem
#'
#' Performs model specific unit conversions on a a list of trait values,
#' such as those provided to write.config
#'
#' @param trait_values a matrix or dataframe of samples from the trait distribution
#' @return matrix or dataframe with values transformed
#' @export
#' @author Shawn Serbin, Tobey Carman
#'
convert.samples.dvmdostem <- function(trait_values) {
  
  if("SLA" %in% names(trait_values)) {
    # Convert from m2 / kg to m2 / g
    trait_values[["SLA"]] <- trait_values[["SLA"]] / 1000.0
  }
  if("cuticular_cond" %in% names(trait_values)) {
    # Convert from umol H2O m-2 s-1 to ???
    # Original values in dvmdostem param files not making sense, no good
    # comments as to units. This conversion seems to make the values match
    # what we expect from the other data in the PEcAn/bety database.
    trait_values[["cuticular_cond"]] <- trait_values[["cuticular_cond"]] / 10^9
  }
  
  if("vpd_open" %in% names(trait_values)) {
    # Convert from kPa to Pa
    trait_values[["vpd_open"]] <- PEcAn.utils::ud_convert(trait_values[["vpd_open"]],"kPa","Pa")
  }
  
  if("vpd_close" %in% names(trait_values)) {
    # Convert from kPa to Pa
    trait_values[["vpd_close"]] <- PEcAn.utils::ud_convert(trait_values[["vpd_close"]],"kPa","Pa")
  }
  
  # Return the modifed version
  return (trait_values)
}
##-------------------------------------------------------------------------------------------------#

##-------------------------------------------------------------------------------------------------#
##' Adjust the runmask for dvmdostem. This is necessary if you are
##' using a mutisite dvmdostem dataset (more than one grid cell/pixel)
##' and you are not forcing the community (cmt or vegetation) type. In 
##' other words you are using a vegetation map to determine the pixel's cmt
##' type. In this case you must make sure that for the site and PFTs
##' you have selected, the underlying veg map classifies the site as the
##' same community type of the PFT you have chosen to run.
##'
##' @name adjust.runmask.dvmdostem
##' @title Adjust runmask for dvmdostem.
##' @param siteDataPath path to expected/default runmask (one of dvmdostem standard input files)
##' @param rundir path to the location for this run (local run directory)
##' @param pixel_X the X coordinate of the pixel to turn on (1 based!)
##' @param pixel_Y the Y coordinate of the pixel to turn on (1 based!)
##' @return NULL
##' @export
##' @author Tobey Carman
##' 
adjust.runmask.dvmdostem <- function(siteDataPath, rundir, pixel_X, pixel_Y) {
  
  # Copy the run-mask from the input data directory to the run directory
  system2(paste0("cp"),
          wait=TRUE,
          args=(c("-r",
                  file.path(siteDataPath, 'run-mask.nc'),
                  file.path(rundir, 'run-mask.nc'))))
  
  # # Turn off all pixels except the 0,0 pixel in the mask
  # Can't seem to use this as python-netcdf4 is not available. WTF.
  # system2(paste0(file.path(appbinary_path, "scripts/runmask-util.py")),
  #         wait=TRUE,
  #         args=c("--reset", "--yx", pixel_Y, pixel_X, file.path(rundir, 'run-mask.nc')))
  
  ## !!WARNING!! See note here:
  ## https://github.com/cran/ncdf4/blob/master/R/ncdf4.R
  ## Permalink: https://github.com/cran/ncdf4/blob/6eea28ce4e457054ff8d4cb90c58dce4ec765fd7/R/ncdf4.R#L1
  ##
  ## Basically:
  ##	1. R starts counting at 1, and netCDF counting
  ##	   starts at 0.
  ##	2. R array subscripts go in Fortran order (XYZT),
  ##	   while netCDF subscripts go in C order (TZYX).
  ##  3. R does not have a 64bit integer datatype (which is the datatype
  ##     of the run mask netCDF file). So we get a warning about casting
  ##     the data from the R integer value to the netCDF 64bit integer
  ncMaskFile <- ncdf4::nc_open(file.path(rundir, 'run-mask.nc'), write = TRUE)
  new_data <- matrix(0, ncMaskFile$dim$X$len, ncMaskFile$dim$Y$len)
  new_data[[strtoi(pixel_X), strtoi(pixel_Y)]] <- 1
  ncdf4::ncvar_put(ncMaskFile, ncMaskFile$var$run, new_data, verbose=TRUE)
  ncdf4::nc_close(ncMaskFile)
  
  PEcAn.logger::logger.info(paste0("Set run mask pixel (y,x)=("),pixel_Y,",",pixel_X,")" )
  
}
##-------------------------------------------------------------------------------------------------#

##-------------------------------------------------------------------------------------------------#
##' Make sure that selected run mask pixel, veg map pixel value and CMT type are all copasetic. The
##' function calls stop() if there is anything inconsistent, for example more tha one pixel is 
##' enabled in the run mask, or the enabled pixel's vegetation type does not match the 
##' vegetation/community type of the chosen PFTs.
##' 
##' @name enforce.runmask.cmt.vegmap.harmony
##' @param siteDataPath is the path to the folder where we expect to find the dvmdostem input data files.
##' @param rundir is the path to the local running directory where customized files (config, parameters, 
##' runmask etc) are copied to.
##' @param cmtnum is the community type (vegetation type) that should be used for the run. Based on the
##' chosen PFT, and required to look up the correct parameters in the parameter files.
##' @return none
##' @export
##' @author Tobey Carman
##'
enforce.runmask.cmt.vegmap.harmony <- function(siteDataPath, rundir, cmtnum){
  
  # Open the runmask and see which pixel is enabled
  ncRunMaskFile <- ncdf4::nc_open(file.path(rundir, "run-mask.nc"), write=FALSE)
  run_mask <- ncdf4::ncvar_get(ncRunMaskFile, ncRunMaskFile$var$run)
  enabled_px <- which(run_mask!=0, arr.ind=TRUE)
  print("========================================================================")
  print(c("length(enabled_px):", length(enabled_px), " enabled_px:", unlist(enabled_px)))
  print("========================================================================")
  if (length(enabled_px != 2)) {
    PEcAn.logger::logger.error("THERE MUST BE A SINGLE PIXEL ENABLED IN THE RUN MASK FILE!")
    PEcAn.logger::logger.error(c("Instead found ", length(enabled_px), " pixels in file: ", file.path(rundir, "run-mask.nc") ) )
    stop()
  }
  
  # Open the input veg file, check that the pixel that is enabled in the
  # run mask is the right veg type to match the cmt/pft that is selected
  # for the run.
  ncVegCMTFile <- ncdf4::nc_open(file.path(siteDataPath, "vegetation.nc"), write=FALSE)
  veg_class <- ncdf4::ncvar_get(ncVegCMTFile, ncVegCMTFile$var$veg_class)
  if (cmtnum != veg_class[[enabled_px[1],enabled_px[2]]]) {
    PEcAn.logger::logger.error("INCORRECT PIXEL!! THIS RUN WILL NOT WORK!")
    PEcAn.logger::logger.error("STOPPING NOW TO PREVENT FUTURE HEARTACHE!")
    stop()
  }
  
}

##-------------------------------------------------------------------------------------------------#
##' Writes a dvmdostem PEcAn config file.
##'
##' Requires a pft xml object, a list of trait values for a single model run,
##' and the name of the file to create
##'
##' @name write.config.dvmdostem
##' @title Write dvmdostem model configuration files
##' @param defaults list of defaults to process
##' @param trait.values vector of samples for a given trait
##' @param settings list of settings from pecan settings file
##' @param run.id id of run
##' @return none
##' @export
##' @author Tobey Carman, Shawn Serbin
##' @importFrom ncdf4 ncvar_put ncvar_get
##' @importFrom rjson fromJSON toJSON
##'
write.config.dvmdostem <- function(defaults = NULL, trait.values, settings, run.id) {
  
  # MAKE SURE TO USE PYTHON 3 FOR dvmdostem v0.5.0 AND UP!!
  # Also on the ubuntu VM, there is a symlink from ~/bin/python to /usr/bin/python3
  # Same sym link setup on modex.
  Sys.setenv(PATH = paste(c("/home/carya/bin", Sys.getenv("PATH")), collapse = .Platform$path.sep))
  Sys.setenv(PATH = paste(c("/home/tcarman/bin", Sys.getenv("PATH")), collapse = .Platform$path.sep))
  #PEcAn.logger::logger.info(system2("python", args="-V"))
  
  ## site information
  ## (Currently unused)
  site <- settings$run$site
  site.id <- as.numeric(site$id)
  
  # Setup some local variables for this function for easily referencing
  # common locations for input, output, and the application binary.
  local_rundir <- file.path(settings$rundir, run.id)    # on local machine for staging
  rundir <- file.path(settings$host$rundir, run.id)     # on remote machine for execution
  outdir <- file.path(settings$host$outdir, run.id)
  appbinary <- settings$model$binary
  appbinary_path <- dirname(appbinary)                  # path of dvmdostem binary file
  
  # On the VM, these seem to be the same.
  PEcAn.logger::logger.info(paste0("local_rundir: ", local_rundir))
  PEcAn.logger::logger.info(paste0("rundir: ", rundir))
  
  # Copy the base set of dvmdostem parameters and configurations into the
  # run directory. Some of the values in these files will be overwritten in
  # subsequent steps, but copying everything up makes sure that all the
  # necessary files exist for a dvmdostem run - the config files and the
  # parameter files in this case.
  if (dir.exists(file.path(rundir, 'config'))) {
    unlink(file.path(rundir, 'config'), recursive=TRUE)
  }
  system2(paste0("cp"),
          wait=TRUE,
          args=(c("-r",
                  file.path(appbinary_path, 'config'),
                  file.path(rundir, 'config'))))  # this seems like a problem with below since we copy this first
                                                  # and below ask if it exists and if so don't copy the template version
  
  if (dir.exists(file.path(rundir, 'parameters'))) {
    unlink(file.path(rundir, 'parameters'), recursive=TRUE)
  }
  system2(paste0("cp"),
          wait=TRUE,
          args=(c("-r",
                  file.path(appbinary_path, 'parameters'),
                  file.path(rundir, 'parameters'))))
  
  
  # Pull out the community name/number for use below in extracting
  # the correct block of data from the dvmdostem parameter files.
  # The settings$pfts$pft$name variable will be something like this: "CMT04-Salix"
  cmtname <- unlist(strsplit(settings$pfts$pft$name, "-", fixed=TRUE))[1]
  cmtnum <- as.numeric(unlist(strsplit(cmtname, "CMT"))[2]) #
  PEcAn.logger::logger.info(paste("cmtname: ", cmtname, " cmtnum: ", cmtnum))
  
  # Check that all selected PFTs (from pecan.xml) have the same CMT number!
  for (pft in settings$pfts) {
    cur_pftname <- pft$name
    cur_cmtname <- unlist(strsplit(cur_pftname, "-", fixed=TRUE))[1]
    cur_cmtnum <- as.numeric(unlist(strsplit(cur_cmtname, "CMT"))[2])
    if (cur_cmtname == cmtname) {
      # pass, evertthing ok
      PEcAn.logger::logger.debug(paste0("All ok - CMTs of all the selected PFTs match."))
    } else {
      PEcAn.logger::logger.error(paste0("CMTs of selected PFTS do not match!!!"))
      stop()
    }
  }
  
  # (1)
  # Read in a parameter data block from dvmdostem
  
  # Now we have to read the appropriate values out of the trait_df
  # and get those values written into the parameter file(s) that dvmdostem will
  # need when running. Because the dvmdostem parameters have a sort of
  # interesting, semi-standardized, space delimited, column format, we'll
  # use some helper scripts from dvmdostem that allow us to more easily
  # handle the parameter files and write our new trait values into the correct
  # place. The basic flow will be like this:
  #  - Read dvmdostem parameter file into json object, load into memory
  #  - Update the in-memory json object
  #  - Write the json object back out to a new dvmdostem parameter file
  
  # Next, use a helper script distributed with dvmdostem to read the dvmdostem
  # parameter data into memory as a json object, using a temporaroy json file
  # to hold a representation of each dvmdostem parameter file.
  dimveg_params <- paste(appbinary_path, "parameters", 'cmt_dimvegetation.txt', sep="/")
  envcanopy_params <- paste(appbinary_path, "parameters", 'cmt_envcanopy.txt', sep="/")
  bgcveg_params <- paste(appbinary_path, "parameters", 'cmt_bgcvegetation.txt', sep="/")
  calparbgc_params <- paste(appbinary_path, "parameters", "cmt_calparbgc.txt", sep="/")
  
  # Call the helper script and write out the data to a temporary file
  # This gets just the block we are interested in (based on community type)
  # create rundir temp directory
  if (! file.exists(file.path(local_rundir, "tmp"))) {
    dir.create(file.path(local_rundir, "tmp"), recursive=TRUE)
  }
  dimveg_jsonfile <- file.path(local_rundir, "tmp",'dvmdostem-dimveg.json')
  PEcAn.logger::logger.info(paste0("dimveg_jsonfile: ", dimveg_jsonfile))
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--dump-block-to-json", dimveg_params, cmtnum)),
          stdout=dimveg_jsonfile, wait=TRUE)
  
  envcanopy_jsonfile <- file.path(local_rundir, "tmp",'dvmdostem-envcanopy.json')
  PEcAn.logger::logger.info(paste0("envcanopy_jsonfile: ", envcanopy_jsonfile))
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--dump-block-to-json", envcanopy_params, cmtnum)),
          stdout=envcanopy_jsonfile, wait=TRUE)
  
  bgcveg_jsonfile <- file.path(local_rundir, "tmp",'dvmdostem-bgcveg.json')
  PEcAn.logger::logger.info(paste0("bgcveg_jsonfile: ", bgcveg_jsonfile))
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--dump-block-to-json", bgcveg_params, cmtnum)),
          stdout=bgcveg_jsonfile, wait=TRUE)
  
  calparbgc_jsonfile <- file.path(local_rundir, "tmp",'dvmdostem-calparbgc.json')
  PEcAn.logger::logger.info(paste0("calparbgc_jsonfile: ", calparbgc_jsonfile))
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--dump-block-to-json", calparbgc_params, cmtnum)),
          stdout=calparbgc_jsonfile, wait=TRUE)
  
  # Read the json file into memory
  dimveg_jsondata <- fromJSON(paste(readLines(dimveg_jsonfile), collapse=""))
  envcanopy_jsondata <- fromJSON(paste(readLines(envcanopy_jsonfile), collapse=""))
  bgcveg_jsondata <- fromJSON(paste(readLines(bgcveg_jsonfile), collapse=""))
  calparbgc_jsondata <- fromJSON(paste(readLines(calparbgc_jsonfile), collapse=""))
  
  # (2)
  # Overwrite parameter values with (ma-posterior) trait data from pecan
  PEcAn.logger::logger.info(paste0("CMT Name: ", cmtname))
  for (singlepft in settings$pfts) {
    PEcAn.logger::logger.info(paste0("PFT Name: ", singlepft$name))
    # Subset the trait.values list to get only the traits for the PFT we are
    # interested in. The trait.values list should be something like this:
    # $`CMT04-Salix`
    #      SW_albedo    gcmax    cuticular_cond       SLA
    #            1.0     3.4               2.5       11.0
    # $`CMT04-Betula`
    #      SW_albedo    gcmax    cuticular_cond       SLA
    #            1.0      3.4               2.5      11.0
    #
    # Where there is a sub-list for each PFT. We want to reduce this to just
    # the PFT we are interested in, and with all the unit conversions taken
    # care of. So result will be something like this:
    # SW_albedo    gcmax    cuticular_cond       SLA
    #      1.0       3.4               2.5      11.0
    
    traits <- convert.samples.dvmdostem(trait.values[[singlepft$name]])
    
    for (curr_trait in names(traits)) {
      for (jd in list(bgcveg_jsondata, envcanopy_jsondata, dimveg_jsondata)) {
        for (i in names(jd)) {
          if (grepl("pft", i)) {
            # The PFT name stored w/in betydb is a combo of the community name
            # and the "common" pft name, always separated by a hyphen. Something
            # like this: "CMT04-Salix". The pft name in the json datastructure
            # will be simply the common name, as stored in the dvmdostem parameter
            # files. So here we extract the "common name" from the betydb PFT
            # name to make sure we are updating the correct spot in the json
            # data structure.
            pft_common_name <- unlist(strsplit(singlepft$name, "-"))[2]
            # In addition, there can be variants, i.e. for calibration, where the name
            # in betydb might be like this: CMT06-Decid.cal, and we need to strip off
            # the variant.
            pft_common_name <- unlist(strsplit(pft_common_name, ".", fixed = TRUE))[1]

            #PEcAn.logger::logger.info(paste0("PFT Name: ",cmtname)) # too verbose
            if (identical(jd[[i]]$name, pft_common_name)) {
              PEcAn.logger::logger.info("Somewhere to stop...")

              if (curr_trait == "cfall_leaf") { calparbgc_jsondata[[i]]$`cfall(0)` = traits[[curr_trait]] }
              if (curr_trait == "cfall_stem") { calparbgc_jsondata[[i]]$`cfall(1)` = traits[[curr_trait]] }
              if (curr_trait == "cfall_root") { calparbgc_jsondata[[i]]$`cfall(2)` = traits[[curr_trait]] }
              if (curr_trait == "nfall_leaf") { calparbgc_jsondata[[i]]$`nfall(0)` = traits[[curr_trait]] }
              if (curr_trait == "nfall_stem") { calparbgc_jsondata[[i]]$`nfall(1)` = traits[[curr_trait]] }
              if (curr_trait == "nfall_root") { calparbgc_jsondata[[i]]$`nfall(2)` = traits[[curr_trait]] }
              if (curr_trait == "krb_leaf") { calparbgc_jsondata[[i]]$`krb(0)` = traits[[curr_trait]] }
              if (curr_trait == "krb_stem") { calparbgc_jsondata[[i]]$`krb(1)` = traits[[curr_trait]] }
              if (curr_trait == "krb_root") { calparbgc_jsondata[[i]]$`krb(2)` = traits[[curr_trait]] }
              if (curr_trait == "kra") { calparbgc_jsondata[[i]]$kra = traits[[curr_trait]] }
              if (curr_trait == "frg") { calparbgc_jsondata[[i]]$frg = traits[[curr_trait]] }
              if (curr_trait == "nmax") { calparbgc_jsondata[[i]]$nmax = traits[[curr_trait]] }
              if (curr_trait == "cmax") { calparbgc_jsondata[[i]]$cmax = traits[[curr_trait]] }
              if (curr_trait == "micbnup") { calparbgc_jsondata[[i]]$micbnup = traits[[curr_trait]] }
              if (curr_trait == "kdcrawc") { calparbgc_jsondata[[i]]$kdcrawc = traits[[curr_trait]] }
              if (curr_trait == "kdcsoma") { calparbgc_jsondata[[i]]$kdcsoma = traits[[curr_trait]] }
              if (curr_trait == "kdcsompr") { calparbgc_jsondata[[i]]$kdcsompr = traits[[curr_trait]] }
              if (curr_trait == "kdcsomcr") { calparbgc_jsondata[[i]]$kdcsomcr = traits[[curr_trait]] }

              if (curr_trait == "SLA") {
                dimveg_jsondata[[i]]$sla = traits[[curr_trait]]
              }
              if (curr_trait == "frprod_perc_10") {
                dimveg_jsondata[[i]]$`frprod[0]` = traits[[curr_trait]]
              }
              if (curr_trait == "frprod_perc_20") {
                dimveg_jsondata[[i]]$`frprod[1]` = traits[[curr_trait]]
              }
              if (curr_trait == "frprod_perc_30") {
                dimveg_jsondata[[i]]$`frprod[2]` = traits[[curr_trait]]
              }
              if (curr_trait == "frprod_perc_40") {
                dimveg_jsondata[[i]]$`frprod[3]` = traits[[curr_trait]]
              }
              if (curr_trait == "frprod_perc_50") {
                dimveg_jsondata[[i]]$`frprod[4]` = traits[[curr_trait]]
              }
              if (curr_trait == "klai") {
                dimveg_jsondata[[i]]$klai = traits[[curr_trait]]
              }
              if (curr_trait == "ilai") {
                dimveg_jsondata[[i]]$initial_lai = traits[[curr_trait]]
              }
              if (curr_trait == "extinction_coefficient_diffuse") {
                envcanopy_jsondata[[i]]$er = traits[[curr_trait]]
              }
              if (curr_trait == "SW_albedo") {
                envcanopy_jsondata[[i]]$albvisnir = traits[[curr_trait]]
              }
              if (curr_trait == "cuticular_cond") {
                envcanopy_jsondata[[i]]$gl_c = traits[[curr_trait]]
              }
              if (curr_trait == "gcmax") {
                envcanopy_jsondata[[i]]$glmax = traits[[curr_trait]]
              }
              if (curr_trait == "ppfd50") {
                envcanopy_jsondata[[i]]$ppfd50 = traits[[curr_trait]]
              }
              if (curr_trait == "vpd_open") {
                envcanopy_jsondata[[i]]$vpd_open = traits[[curr_trait]]
              }
              if (curr_trait == "vpd_close") {
                envcanopy_jsondata[[i]]$vpd_close = traits[[curr_trait]]
              }
              if (curr_trait == "pstemp_min") {
                bgcveg_jsondata[[i]]$tmin = traits[[curr_trait]]
              }
              if (curr_trait == "pstemp_low") {
                bgcveg_jsondata[[i]]$toptmin = traits[[curr_trait]]
              }
              if (curr_trait == "pstemp_high") {
                bgcveg_jsondata[[i]]$toptmax = traits[[curr_trait]]
              }
              if (curr_trait == "pstemp_max") {
                bgcveg_jsondata[[i]]$tmax = traits[[curr_trait]]
              }
              if (curr_trait == "labncon") {
                bgcveg_jsondata[[i]]$labncon = traits[[curr_trait]]
              }
            }
          }
        } # end loop over names in json
      } # end loop over different json structures
    } # end loop over traits
  } # end loop over pfts
  
  # Write it back out to disk (overwriting ok??)
  dimveg_exportJson <- toJSON(dimveg_jsondata)
  write(dimveg_exportJson, file.path(local_rundir, "tmp","dimveg_newfile.json"))
  
  envcanopy_exportJson <- toJSON(envcanopy_jsondata)
  write(envcanopy_exportJson, file.path(local_rundir, "tmp","envcanopy_newfile.json"))
  
  bgcveg_exportJson <- toJSON(bgcveg_jsondata)
  write(bgcveg_exportJson, file.path(local_rundir, "tmp","bgcveg_newfile.json"))
  
  calparbgc_exportJson <- toJSON(calparbgc_jsondata)
  write(calparbgc_exportJson, file.path(local_rundir, "tmp", "calparbgc_newfile.json"))

  # (3)
  # Format a new dvmdostem parameter file using the new json file as a source.
  
  if (dir.exists(file.path(rundir, "parameters/"))) {
    # pass
  } else {
    print("No parameter/ directory in run directory! Need to create...")
    dir.create(file.path(rundir,"parameters" ))
  }
  
  ref_file <- paste0(file.path(appbinary_path, "parameters/"), 'cmt_dimvegetation.txt')
  new_param_file <- paste0(file.path(local_rundir, "parameters/"), "cmt_dimvegetation.txt")
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--fmt-block-from-json", file.path(local_rundir, "tmp","dimveg_newfile.json"), ref_file)),
          stdout=new_param_file, wait=TRUE)
  
  ref_file <- paste0(file.path(appbinary_path, "parameters/"), 'cmt_envcanopy.txt')
  new_param_file <- paste0(file.path(local_rundir, "parameters/"), "cmt_envcanopy.txt")
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--fmt-block-from-json", file.path(local_rundir, "tmp","envcanopy_newfile.json"), ref_file)),
          stdout=new_param_file, wait=TRUE)
  
  ref_file <- paste0(file.path(appbinary_path, "parameters/"), 'cmt_bgcvegetation.txt')
  new_param_file <- paste0(file.path(local_rundir, "parameters/"), "cmt_bgcvegetation.txt")
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--fmt-block-from-json", file.path(local_rundir, "tmp","bgcveg_newfile.json"), ref_file)),
          stdout=new_param_file, wait=TRUE)

  ref_file <- paste0(file.path(appbinary_path, "parameters/"), 'cmt_calparbgc.txt')
  new_param_file <- paste0(file.path(local_rundir, "parameters/"), "cmt_calparbgc.txt")
  system2(paste0(appbinary_path,"/scripts/param_util.py"),
          args=(c("--fmt-block-from-json", file.path(local_rundir, "tmp","calparbgc_newfile.json"), ref_file)),
          stdout=new_param_file, wait=TRUE)
  
  ## Cleanup rundir temp directory - comment out for debugging
  unlink(file.path(local_rundir, "tmp"), recursive = TRUE, force = FALSE)  # comment out for debugging
  
  # TODO:
  #  [x] finish with parameter update process
  #  [x] dynamically copy parameters to right place
  #  [x] dynamically copy the output_spec from insts folder to the
  #      right place (see variable above for getting stuff from inst)
  #  - figure out how to handle the met.
  #     -> step one is symlink from raw data locations (Model install folder)
  #        into pecan run folder, maybe do this within job.sh?
  
  # Here we set up two things: 
  #  1) the paths to the met drivers (temperature, precip, etc)
  #  2) paths to the other input data files that dvmdostem requires (soil maps, 
  #     vegetation maps, topography etc).
  # This will allow us to source the meteorology data from PEcAn (or BetyDB) and 
  # collect the other inputs from a different location.
  
  # Met info
  met_driver_dir <- dirname(settings$run$inputs$met$path)
  # Not sure what happens here if the site is selected from the
  # map and instead of having <met><path> tags, the xml file has
  # <met><id> tags?
  
  # Pick up the site and pixel settings from the xml file if they exist
  if (is.null(settings$model$dvmdostem_site)){
    # Client did not setup a dvmdostem specific site tags in the
    # xml file. Assume that all the site data has the same path
    # as the met data
    siteDataPath <- met_driver_dir
  } else {
    # Pull out the client's settings from the xml file.
    siteDataPath <- settings$model$dvmdostem_site
  }
  PEcAn.logger::logger.info(paste0("Using siteDataPath: ", siteDataPath))
  PEcAn.logger::logger.info(paste0("Using met_driver_path: ", met_driver_dir))
  
  # Check the size of the input dataset(s)
  # 1) met data set and other site data are the same size/shape (what if the
  #    met comes from PEcAn/Bety and is single site and the other inputs come
  #    from a single or multi-pixel dvmdostem dataset???)
  # 2) if the incoming datasets are NOT single pixel, then 
  #    we need to adjust the run-mask and choose the correct pixel
  # 3) if the incoming datasets ARE single pixel, then no runmask
  #    adjustment, but warn user if they have set dvmdostem_pixel_x
  #    and dvmdostem_pixel_y tags in the xml file
  
  if (is.null(settings$model$dvmdostem_pixel_y)){
    pixel_Y <- 1
  } else {
    pixel_Y <- settings$model$dvmdostem_pixel_y
  }
  if (is.null(settings$model$dvmdostem_pixel_x)){
    pixel_X <- 1
  } else {
    pixel_X <- settings$model$dvmdostem_pixel_x
  }
  
  # First, turn on a specific pixel in the run mask.
  # In the case of a single pixel dataset, this will ensure that the
  # pixel is set to run.
  adjust.runmask.dvmdostem(siteDataPath, rundir, pixel_X, pixel_Y)
  
  # If the user has not explicity said to force the CMT type in
  # their xml settings, then we have to look at the run mask, figure out
  # which pixel is enabled, and then check the corresponding pixel in the
  # veg map to make sure that cmt number matches the cmt number for the
  # chosen PFTs.
  if ((toupper(settings$model$dvmdostem_forcecmtnum) == 'YES') || (toupper(settings$model$dvmdostem_forcecmtnum) == "Y")) {
    # Nothing to do
  } else {
    print("Enforcing harmony between the runmask, vegmap, and required CMT type.")
    enforce.runmask.cmt.vegmap.harmony(siteDataPath, rundir, cmtnum)
  }
  
  # if (!is.null(settings$model$dvmdostem_calibration)){
  #   if (grepl(settings$model$dvmdostem_calibration, "yes", ignore.case = TRUE)) {
  #     # Ignore the following:
  #     #     settings$model$dvmdostem_output_spec
  #     #     settings$model$dvmdostem_pecan_outputs variables
  #     # Copy the base file to a run-specific output spec file
  #     if (! file.exists(file.path(rundir, "config")) ) {
  #       dir.create(file.path(rundir, "config"), recursive = TRUE)
  #     }
  #     rs_outspec_path <- file.path(rundir, "config/", basename(outspec_path))
  #     file.copy(outspec_path, rs_outspec_path)
  # 
  # 
  # } else {
  #   
  # }
  

  # # A more sophisticated test will verify that all the variables 
  # # are valid at the correct dimensions(month and year??)
  # 
  # # Empty the run specific output spec file
  # system2(file.path(appbinary_path, "scripts/outspec_utils.py"), 
  #         args=c("--empty", rs_outspec_path))
  # 
  # # Fill the run specific output spec file according to list
  # for (j in req_v_list) {
  #   system2(file.path(appbinary_path, "scripts/outspec_utils.py"),
  #           args=c(rs_outspec_path, "--on", j, "y", "m"))
  # }
  # 
  # # Print summary for debugging
  # #system2(file.path(appbinary_path, "scripts/outspec_utils.py"), 
  # #        args=c("-s", rs_outspec_path))
  # 
  # return(c(rs_outspec_path, req_v_str))
  
  # setup the variables to output based on tags in xml file.
  v <- setup.outputs.dvmdostem(
    settings$model$dvmdostem_calibration,
    settings$model$dvmdostem_pecan_outputs, 
    settings$model$dvmdostem_output_spec,
    rundir, run.id, appbinary_path
  )
  rs_outspec_path <- v[1]
  PEcAn.logger::logger.info(paste0("Will be generating the following dvmdostem output variables: ", v[2]))
  
  ## Update dvm-dos-tem config.js file
  
  # Get a copy of the config file written into the run directory with the
  # appropriate template parameters substituted.
  if (!is.null(settings$model$configtemplate) && file.exists(settings$model$configtemplate)) {
    config_template <- readLines(con=settings$model$config_template, n=-1)
  } else {
    config_template <- readLines(con=system.file("config.js.template", package = "PEcAn.dvmdostem"), n=-1)
  }
  
  config_template <- gsub("@MET_DRIVER_DIR@", met_driver_dir, config_template)
  #config_template <- gsub("@INPUT_DATA_DIR@", file.path(dirname(appbinary), siteDataPath), config_template)
  config_template <- gsub("@INPUT_DATA_DIR@", siteDataPath, config_template)
  config_template <- gsub("@MODEL_OUTPUT_DIR@", outdir, config_template)
  config_template <- gsub("@CUSTOM_RUN_MASK@", file.path(rundir), config_template)
  config_template <- gsub("@CUSTOM_OUTSPEC@", file.path("config/", basename(rs_outspec_path)), config_template)
  config_template <- gsub("@DYNAMIC_MODELED_LAI@", settings$model$dvmdostem_dynamic_modeled_lai, config_template)
  if (grepl(tolower(settings$model$dvmdostem_calibration), "yes", fixed=TRUE)) {
    config_template <- gsub("@EQ_NC_OUTPUT@", 1, config_template)  # WARNING, output volume can be prohibitive!
    config_template <- gsub("@NC_OUTPUT_LAST_N_EQ@", settings$model$dvmdostem_nc_output_last_n_eq, config_template)
  } else {
    config_template <- gsub("@EQ_NC_OUTPUT@", 0, config_template)
    config_template <- gsub("@NC_OUTPUT_LAST_N_EQ@", -1, config_template)
  }
  if (! file.exists(file.path(settings$rundir, run.id,"config")) ) {
    dir.create(file.path(settings$rundir, run.id,"config"),recursive = TRUE)
  }
  
  writeLines(config_template, con=file.path(settings$rundir, run.id,"config/config.js"))
  
  ### create launch script (which will create symlink) - needs to be created
  if (!is.null(settings$model$jobtemplate) && file.exists(settings$model$jobtemplate)) {
    jobsh <- readLines(con=settings$model$jobtemplate, n=-1)
  } else {
    jobsh <- readLines(con=system.file("job.sh.template", package = "PEcAn.dvmdostem"), n=-1)
  }
  
  ### create host specific setttings - stubbed for now, nothing to do yet, ends up as empty
  ### string that is put into the job.sh file
  hostsetup <- ""
  if (!is.null(settings$model$prerun)) {
    hostsetup <- paste(hostsetup, sep="\n", paste(settings$model$prerun, collapse="\n"))
  }
  if (!is.null(settings$host$prerun)) {
    hostsetup <- paste(hostsetup, sep="\n", paste(settings$host$prerun, collapse="\n"))
  }
  
  hostteardown <- ""
  if (!is.null(settings$model$postrun)) {
    hostteardown <- paste(hostteardown, sep="\n", paste(settings$model$postrun, collapse="\n"))
  }
  if (!is.null(settings$host$postrun)) {
    hostteardown <- paste(hostteardown, sep="\n", paste(settings$host$postrun, collapse="\n"))
  }
  
  jobsh <- gsub("@HOST_SETUP@", hostsetup, jobsh)
  jobsh <- gsub("@HOST_TEARDOWN@", hostteardown, jobsh)
  
  jobsh <- gsub("@RUNDIR@", rundir, jobsh)
  jobsh <- gsub("@OUTDIR@", outdir, jobsh)
  jobsh <- gsub("@BINARY@", appbinary, jobsh)
  
  ## model specific options from the pecan.xml file
  # setup defaults if missing - may not want to do this long term
  if (is.null(settings$model$dvmdostem_prerun)){
    jobsh <- gsub("@PRERUN@", 100, jobsh)
  } else {
    jobsh <- gsub("@PRERUN@", settings$model$dvmdostem_prerun, jobsh)
  }
  
  if (is.null(settings$model$dvmdostem_equil)){
    jobsh <- gsub("@EQUILIBRIUM@", 1000, jobsh)
  } else {
    jobsh <- gsub("@EQUILIBRIUM@", settings$model$dvmdostem_equil, jobsh)
  }
  
  if (is.null(settings$model$dvmdostem_spinup)){
    jobsh <- gsub("@SPINUP@", 450, jobsh)
  } else {
    jobsh <- gsub("@SPINUP@", settings$model$dvmdostem_spinup, jobsh)
  }
  
  if (is.null(settings$model$dvmdostem_transient)){
    jobsh <- gsub("@TRANSIENT@", 109, jobsh)  # what if this isn't the case?  Do we want to hard code backup or just end in error?
  } else {                                    # could just invoke a stop() here for these if missing and provide an error message
    jobsh <- gsub("@TRANSIENT@", settings$model$dvmdostem_transient, jobsh)
  }
  
  if (is.null(settings$model$dvmdostem_scenerio)){
    jobsh <- gsub("@SCENERIO@", 91, jobsh)
  } else {
    jobsh <- gsub("@SCENERIO@", settings$model$dvmdostem_scenerio, jobsh)
  }
  
  if (is.null(settings$model$dvmdostem_loglevel)){
    jobsh <- gsub("@LOGLEVEL@", "err", jobsh)
  } else {
    jobsh <- gsub("@LOGLEVEL@", settings$model$dvmdostem_loglevel, jobsh)
  }
  
  if (is.null(settings$model$dvmdostem_forcecmtnum)){
    PEcAn.logger::logger.info("Using vegetation.nc input file to determine community type of pixel...")
    PEcAn.logger::logger.warn("The CMT type of your selected PFT must match the CMT type in the input veg file for the selected pixel!")
    jobsh <- gsub("@FORCE_CMTNUM@", "", jobsh)
  } else {
    PEcAn.logger::logger.info("FORCING cmt type to match selected PFT. IGNORING vegetation.nc map!")
    jobsh <- gsub("@FORCE_CMTNUM@", paste0("--force-cmt ", cmtnum), jobsh)
  }
  
  jobsh <- gsub("@PECANREQVARS@", settings$model$dvmdostem_pecan_outputs, jobsh)
  
  # Really no idea what the defaults should be for these if the user
  # does not specify them in the pecan.xml file...
  if (is.null(settings$run$start.date)) {
    jobsh <- gsub("@RUNSTART@", "", jobsh)
  } else {
    jobsh <- gsub("@RUNSTART@", settings$run$start.date, jobsh)
  }
  
  if (is.null(settings$run$end.date)) {
    jobsh <- gsub("@RUNEND@", "", jobsh)
  } else {
    jobsh <- gsub("@RUNEND@", settings$run$end.date, jobsh)
  }
  
  writeLines(jobsh, con=file.path(settings$rundir, run.id,"job.sh"))
  Sys.chmod(file.path(settings$rundir, run.id,"job.sh"))
  
} # end of function
#------------------------------------------------------------------------------------------------#
### EOF
