#-------------------------------------------------------------------------------
# Copyright (c) 2012 University of Illinois, NCSA.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the 
# University of Illinois/NCSA Open Source License
# which accompanies this distribution, and is available at
# http://opensource.ncsa.illinois.edu/license.html
#-------------------------------------------------------------------------------

# ----------------------------------------------------------------------
# PRIVATE FUNCTIONS
# ----------------------------------------------------------------------
data.fetch <- function(var, nc, fun = mean) {
  # get a specific set of values from the HDF data
  #
  # Args:
  #   var:    the variable to extract from the hdf data
  #   nc:
  #   time:
  #   fun:    the function to apply to the data at the same time
  #
  # Returns:
  #   values extracted from the nc data
  if (var == "time") {
    val <- unique(floor(nc$dim[["time"]]$vals))
    attr(val, "lbl") <- nc$dim$time$units
    return(val)
  }
  
  # some precomputations
  indices  <- 0:length(nc$dim[["time"]]$vals)
  aggrlist <- list(floor(nc$dim[["time"]]$vals))
  
  # aggregate the data
  data <- ncdf4::ncvar_get(nc, var)
  val  <- stats::aggregate(data[indices], by = aggrlist, FUN = fun)$x
  
  # get the label
  title <- nc$var[[var]]$longname
  units <- nc$var[[var]]$units
  if ((title == "") && (units == "")) {
    attr(val, "lbl") <- "Unknown"
  } else if (title == "") {
    attr(val, "lbl") <- paste("Unknown in ", units)
  } else if (units == "") {
    attr(val, "lbl") <- title
  } else {
    attr(val, "lbl") <- paste(title, "in", units)
  }
  
  # done
  return(val)
}  # data.fetch

# ----------------------------------------------------------------------
# MAIN FUNCTIONS
# ----------------------------------------------------------------------
########################## CREATE PLOT #################################

##' Load the tower dataset and create a plot.
##'
##' Loads the tower data from an HDF5 file generated by
##' ED and will plot the values against one another. The default is for
##' the given variable to be plotted against time.
##'
##' @param datafile the specific datafile to use.
##' @param yvar the variable to plot along the y-axis.
##' @param xvar the variable to plot along the x-axis, by default time is
##' used.
##' @param width the width of the image generated, default is 800 pixels.
##' @param height the height of the image generated, default is 600 pixels.
##' @param filename is the name of the file name that is geneated, this
##'        can be null to use existing device, otherwise it will try and
##'        create an image based on filename, or display if x11.
##' @param year the year this data is for (only used in the title).
##'
##' @aliases plot.netcdf
##' @export
##' @author Rob Kooper
plot_netcdf <- function(datafile, yvar, xvar = "time", width = 800, height = 600,
                        filename = NULL, year = NULL) {
  # open netcdf file
  nc <- ncdf4::nc_open(datafile)
  
  # compute variables
  xval_mean <- data.fetch(xvar, nc, mean)
  yval_mean <- data.fetch(yvar, nc, mean)
  yval_max  <- data.fetch(yvar, nc, max)
  yval_min  <- data.fetch(yvar, nc, min)
  
  # setup output
  if (!is.null(filename)) {
    if (tolower(filename) == "x11") {
      grDevices::x11(width = width / 96, height = height / 96)
    } else if (tolower(stringr::str_sub(filename, -4)) == ".png") {
      grDevices::png(filename = filename, width = width, height = height)
    } else if (tolower(stringr::str_sub(filename, -4)) == ".pdf") {
      grDevices::pdf(file = filename, width = width, height = height)
    } else if (tolower(stringr::str_sub(filename, -4)) == ".jpg") {
      grDevices::jpeg(filename = filename, width = width, height = height)
    } else if (tolower(stringr::str_sub(filename, -5)) == ".tiff") {
      grDevices::tiff(filename = filename, width = width, height = height)
    }
  }
  
  # setup plot (needs to be done before removing of NA since that removes attr as well).
  graphics::plot.new()
  graphics::title(xlab = attr(xval_mean, "lbl"))
  graphics::title(ylab = attr(yval_mean, "lbl"))
  if (xvar == "time") {
    if (is.null(year)) {
      graphics::title(main = nc$var[[yvar]]$longname)
    } else {
      graphics::title(main = paste(nc$var[[yvar]]$longname, "for", year))
    }
  } else {
    if (is.null(year)) {
      graphics::title(main = paste(xvar, "VS", yvar))
    } else {
      graphics::title(main = paste(xvar, "VS", yvar, "for", year))
    }
  }
  # done with netcdf file
  ncdf4::nc_close(nc)
  
  # remove all NA's
  removeme <- unique(c(which(is.na(yval_min)), 
                       which(is.na(xval_mean)), 
                       which(is.na(yval_mean)), 
                       which(is.na(yval_max))))
  if (length(removeme) > 0) {
    xval_mean <- xval_mean[-removeme]
    yval_mean <- yval_mean[-removeme]
    yval_max <- yval_max[-removeme]
    yval_min <- yval_min[-removeme]
  }
  yvals <- c(yval_max, yval_min)
  
  # order data based on x values
  o <- order(xval_mean, yval_mean)
  
  # plot actual data
  graphics::plot.window(xlim = c(min(xval_mean), max(xval_mean)),
              ylim = c(min(yvals), max(yvals)))
  graphics::polygon(
    c(xval_mean[o], rev(xval_mean[o])),
    c(yval_max[o], rev(yval_min[o])),
    col = "gray",
    border = "black")
  graphics::lines(x = xval_mean[o], y = yval_mean[o], col = "red")
  graphics::points(
    x = xval_mean[o],
    y = yval_mean[o],
    col = "black",
    pch = ".",
    cex = 5)

  # legend
  graphics::legend("bottomright", col = c(1, "gray"), lwd = c(3, 6),
         legend = c("mean", "min/max"),
         cex = 1.5)

  # draw axis and box
  graphics::axis(1)
  graphics::axis(2)
  graphics::box()

  ## add PEcAn icon
  add_icon()

  if (!is.null(filename) && (tolower(filename) != "x11")) {
    grDevices::dev.off()
  }
}  # plot_netcdf
