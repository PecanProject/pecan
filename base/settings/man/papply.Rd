% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/papply.R
\name{papply}
\alias{papply}
\title{Apply functions to PEcAn MultiSettings}
\usage{
papply(settings, fn, ..., stop.on.error = FALSE)
}
\arguments{
\item{settings}{A \code{\link{MultiSettings}}, \code{\link{Settings}}, or \code{\link[base]{list}}
to operate on}

\item{fn}{The function to apply to \code{settings}}

\item{stop.on.error}{Whether to halt execution if a single element in \code{settings} results 
in error. See Details.}

\item{\code{...}}{additional arguments to \code{fn}}
}
\value{
A single \code{fn} return value, or a list of such values (coerced to \code{MultiSettings} 
if appropriate; \emph{see Details})
}
\description{
Works like lapply(), but for PEcAn Settings and MultiSettings objects
}
\details{
\code{papply} is mainly used to call a function on each \code{\link{Settings}} object in a 
\code{\link{MultiSettings}} object, and returning the results in a list. It has some additional 
features, however:

\itemize{
  \item If the result of \code{fn} is a \code{Settings} object, then \code{papply} will coerce the 
returned list into a new \code{MultiSettings}. 
  \item If \code{settings} is a \code{Settings} object, then \code{papply} knows to call \code{fn} on 
it directly.
  \item If \code{settings} is a generic \code{list}, then \code{papply} coerces it to a
  \code{Settings} object and then calls \code{fn} on it directly. This is meant for backwards
  compatibility with old-fashioned PEcAn settings lists, but could have unintended consequences
  \item By default, \code{papply} will proceed even if \code{fn} throws an error for one or more
  of the elements in \code{settings}. Note that if this option is used, the returned results 
  list will have entries for \emph{only} those elements that did not result in an error. 
}
}
\examples{
f = function(settings, ...) {
  # Here's how I envisioned a typical use case within a standard PEcAn function
  if(is.MultiSettings(settings)) {
    return(papply(settings, f, ...))
  }
  
  # Don't worry about the beolow, it's just some guts to make the function do something we can see
  l <- list(...)
  for(i in seq_along(l)) {
    ind <- length(settings) + 1
    settings[[ind]] <- l[[i]]
    if(!is.null(names(l))) {
      names(settings)[ind] <- names(l)[i]
    }
  }
  return(settings)
}

# Example
settings1 <- Settings(list(a="aa", b=1:3, c="NA"))
settings2 <- Settings(list(a="A", b=4:5, c=paste))
multiSettings <- MultiSettings(settings1, settings2)

# The fucntion should add element $d = D to either a Settings, or each entry in a MultiSettings
f(settings1, d="D")
print(f(multiSettings, d="D"), TRUE)

}
\author{
Ryan Kelly
}
