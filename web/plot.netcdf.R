#-------------------------------------------------------------------------------
# Copyright (c) 2012 University of Illinois, NCSA.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the 
# University of Illinois/NCSA Open Source License
# which accompanies this distribution, and is available at
# http://opensource.ncsa.illinois.edu/license.html
#-------------------------------------------------------------------------------
library(XML)
library(ncdf)

# ----------------------------------------------------------------------
# COMMAND LINE ARGUMENTS
# ----------------------------------------------------------------------
# arguments are --args year variable
args     <- commandArgs(trailingOnly = TRUE)
datafile <- args[1]
year     <- args[2]
xvar     <- 'time'
yvar     <- args[3]
width    <- as.numeric(args[4])
height   <- as.numeric(args[5])
filename <- args[6]

# time goes from 0 to 23
starttime=0
endtime=23

# ----------------------------------------------------------------------
# SETUP
# ----------------------------------------------------------------------
settings.file <- Sys.getenv('PECANSETTINGS')
settings.xml <- xmlParse(settings.file)
settings <- xmlToList(settings.xml)

#year=2006
#yvar="AVG_PAR_BEAM"
#width=800
#height=600
#filename="/tmp/plot.png"
#settings <- xmlToList(xmlParse("/home/kooper/tmp/pecan/PEcAn_56/pecan.xml"))

# ----------------------------------------------------------------------
# CONSTANTS
# ----------------------------------------------------------------------
# This depends on NL%FRQFAST in template and should reflect the number of
# data points written per day.
values_day <- 24

# ----------------------------------------------------------------------
# PRIVATE FUNCTIONS
# ----------------------------------------------------------------------
data.fetch <- function(var, nc, start, end, values, fun=mean) {
	# get a specific set of values from the HDF data
	#
	# Args:
	#   var:    the variable to extract from the hdf data
	#   start:  the start time in the array
	#   end:    the end time in the array
	#   values: number of values per day
	#   fun:    the function to apply to the data at the same time
	#
	# Returns:
	#   values extracted from the hdf data
	
	if (var == "time") {
		val <- unique(floor(nc$dim[['time']]$vals / (24*3600)))
		attr(val, "lbl") <- "Day of the year"
		return(val)
	}
	
	# find the variable in the data
	if (is.null(nc$var[[var]])) {
		useme <- sprintf("AVG_%s", var)
		if (is.null(nc$var[[useme]])) {
			stop(sprintf("Could not find the variable '%s' in the data.", var))
		}
	} else {
		useme <- var
	}
	
	# some precomputations
#	lastval  <- (values_day*(1+end-start))
#	indices <- c(lapply(start:(end),function(x) {seq(1+x*values_day+starttime, 1+x*values_day+endtime)}), recursive=TRUE)
#	aggrlist <- list(rep(start:(end), each=(1 + endtime - starttime)))
        indices  <- 0:length(nc$dim[['time']]$vals)
        aggrlist <- list(floor(nc$dim[['time']]$vals / (24*3600)))
	
	# aggregate the data
	data <- get.var.ncdf(nc, useme)
	val <- aggregate(data[indices], by=aggrlist, FUN=fun)$x
	if (length(grep("TE?MP$", useme)) != 0) {
		val[val<200] <- NA
	}
	
	# get the label
	title <- nc$var[[useme]]$longname
	units <- nc$var[[useme]]$units
	if ((title == "") && (units == "")) {
		attr(val, "lbl") <- "Unknown"
	} else if (title == "") {
		attr(val, "lbl") <- paste("Unknown in ", units)
	} else if (units == "") {
		attr(val, "lbl") <- title
	} else {
		attr(val, "lbl") <- paste(title, "in", units)
	}
	
	# done
	return(val)
}

# ----------------------------------------------------------------------
# MAIN FUNCTIONS
# ----------------------------------------------------------------------
########################## CREATE PLOT #################################
##' Load the tower dataset and create a plot.
##' @name plot.hdf5
##'
##' \code{plot.hdf5} loads the tower data from an HDF5 file generated by
##' ED and will plot the values against one another. The default is for
##' the given variable to be plotted against time.
##'
##' @param datafile the specific datafile to use.
##' @param year the specific year to use.
##' @param yvar the variable to plot along the y-axis.
##' @param xvar the variable to plot along the x-axis, by default time is
##' used.
##' @param the width of the image generated, default is 800 pixels.
##' @param the height of the image generated, default is 600 pixels.
##' @param filename is the name of the file name that is geneated.
##' @param settings the pecan.xml file loaded.
plot.netcdf <- function(datafile, year, yvar, xvar='time', width=800, height=600, filename, settings) { 
	# find out the first/last day of the plot
	start_date <- as.Date(settings$run$start.date)
	start_year <- format(start_date, "%Y")
	end_date <- as.Date(settings$run$end.date)
	end_year <- format(end_date, "%Y")
#	if (year == start_year) {
#		start_day <- as.numeric(format(start_date, "%j")) - 1
#	} else {
		start_day <- 0
#	}
	if (year == end_year) {
		end_day <- as.numeric(format(end_date, "%j")) - 1
	} else {
		end_day <- as.numeric(format(as.Date(sprintf("%s-12-31", year)), "%j")) - 1
	}
	
	# open netcdf file
	nc <- open.ncdf(paste(settings$run$host$outdir, datafile, sep="/"))
	
	# compute variables
	xval_mean <- data.fetch(xvar, nc, start_day, end_day, values_day, mean)
	xval_max  <- data.fetch(xvar, nc, start_day, end_day, values_day, max)
	xval_min  <- data.fetch(xvar, nc, start_day, end_day, values_day, min)
	yval_mean <- data.fetch(yvar, nc, start_day, end_day, values_day, mean)
	yval_max  <- data.fetch(yvar, nc, start_day, end_day, values_day, max)
	yval_min  <- data.fetch(yvar, nc, start_day, end_day, values_day, min)
	
	# done with netcdf file
	close.ncdf(nc)
	
	# setup plot (needs to be done before removing of NA since that removes attr as well).
	png(filename=filename, width=width, height=height)
	plot.new()
	title(xlab=attr(xval_mean, "lbl"))
	title(ylab=attr(yval_mean, "lbl"))
	if (xvar == "time") {
		title(main=paste(yvar))
	} else {
		title(main=paste(xvar, "VS", yvar))
	}
	
	# remove all NA's
	removeme <- unique(c(which(is.na(xval_min)), which(is.na(yval_min)), which(is.na(xval_mean)), which(is.na(yval_mean)), which(is.na(xval_max)), which(is.na(yval_max))))
	if (length(removeme) > 0) {
		xval_mean <- xval_mean[-removeme]
		xval_max  <- xval_max[-removeme]
		xval_min  <- xval_min[-removeme]
		yval_mean <- yval_mean[-removeme]
		yval_max  <- yval_max[-removeme]
		yval_min  <- yval_min[-removeme]
	}
	
	# combine
	xvals <- c(xval_max, rev(xval_min))
	yvals <- c(yval_max, rev(yval_min))
	
	# plot actual data
	plot.window(xlim=c(min(xvals), max(xvals)), ylim=c(min(yvals), max(yvals)))
	polygon(c(xval_max, rev(xval_min)), c(yval_max, rev(yval_min)), col="gray", border="black")
	points(xval_mean, yval_mean, col="black", pch=20)
	
	# draw axis and box
	axis(1)
	axis(2)
	box()
	dev.off()
}

plot.netcdf(datafile, year, yvar, xvar, width, height, filename, settings);
