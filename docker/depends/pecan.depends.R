#!/usr/bin/env Rscript

# Don't use X11 for rgl
Sys.setenv(RGL_USE_NULL = TRUE)
rlib <- Sys.getenv('R_LIBS_USER', '/usr/local/lib/R/site-library')
Sys.setenv(RLIB = rlib)


# Find the latest of several possible minimum package versions
condense_version_requirements <- function(specs) {
  if (all(specs ==  "*")) {
    # any version is acceptable
    return("*")
  }
  specs <- unique(specs[specs != "*"])
  versions <- package_version(
    gsub("[^[:digit:].-]+", "", specs))
  
  if ((length(unique(versions)) > 1) && any(!grepl(">", specs))) {
    # Can't assume the latest version works for all, so give up.
    # We *could* write more to handle this case if needed, but it seems very rare:
    # available.packages() shows `<=` or `==` deps in just 4 of 20297 CRAN packages
    #
    # Since the package name wasn't passed in here, we unhelpfully print *just*
    #   the offending versions and send the user back to the CSV for details.
    stop(
      "Found multiple version requirements (",
      paste(dQuote(specs), collapse = ", "), ") for the same dependency, ",
      "and not all are minimum versions (e.g. `>= x.y.z`). ",
      "Exact (`==`) or maximum (`<=`) version reuirements are only allowed ",
      "if all PEcAn packages declare the same version. ",
      "Sorry, this function doesn't know which dependency caused this. ",
      "To find it, search for these version strings in ",
      "'pecan_package_dependencies.csv'.")
  }
  specs[versions == max(versions)]
}

# Install <version> or newer,
# upgrading dependencies only if needed to satisfy stated version requirements
ensure_version <- function(pkg, version) {
  vers <- gsub('[^[:digit:].-]+', '', version)
  cmp <- get(gsub('[^<>=]+', '', version))
  ok <- requireNamespace(pkg, quietly = TRUE) &&
    cmp(packageVersion(pkg), vers)
  if (!ok) {
    # install pkg and any *missing* dependencies
    remotes::install_version(pkg, version, dependencies = TRUE, upgrade = FALSE)
    # Now check for installed but *incompatible* dependencies
    # (install_version doesn't resolve these when upgrade=FALSE)
    dep <- desc::desc_get_deps(system.file("DESCRIPTION", package = pkg))
    dep <- dep[
      dep$type %in% c("Depends", "Imports", "LinkingTo")
      & dep$version != "*"
      & dep$package != "R",]
    invisible(Map(ensure_version, dep$package, dep$version))
  }
  
}

# Read list of dependencies.
# NOTE: These files are autogenerated --
# use scripts/generate_dependencies.R to edit them.
all_deps <- read.csv("pecan_package_dependencies.csv") |>
  subset(!is_pecan)
gh_repos <- readLines("pecan_deps_from_github.txt")


# install remotes first, so they're present when checked as dependencies
# NOTE: script doesn't know what package a given repo provides,
#   it just installs whatever it finds at each address.
remotes::install_github(gh_repos, lib = rlib)


# For deps used by multiple packages, find a version that works for all
uniq_deps <- tapply(
  all_deps$version,
  INDEX = all_deps$package,
  FUN = condense_version_requirements)


# Install deps that declare no version restriction.
# We'll install these with one plain old `install.packages()` call.
unversioned <- names(uniq_deps[uniq_deps == "*"])
missing <- unversioned[!(unversioned %in% installed.packages()[,'Package'])]
install.packages(missing, lib = rlib)


# Install deps that need a set minimum version.
# We'll install these with `remotes::install_version`,
# directing it to look outside our fixed-date CRAN snapshot if
# it can't fill the version req from snapshot versions.
# (Assumes our CRAN uses the same URL scheme as Posit package manager)
options(repos = c(
  getOption('repos'),
  sub(r'(\d{4}-\d{2}-\d{2})', 'latest', getOption('repos'))
))
versioned <- uniq_deps[uniq_deps != "*"]
invisible(Map(ensure_version, names(versioned), versioned))